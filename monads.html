<h1 id="what-are-monads"><span class="header-section-number">1</span> What are Monads?</h1>
<p>It is entirely reasonable that this is the first question that anyone learning Monads asks, and it is also entirely reasonable that anyone who is teaching Monads tries to answer it. However, Monads are a complex concept that cannot be explained in a single sentence or even a single paragraph; to understand Monads you must simultaneously understand the problem they are trying to solve, their implementation, the interface for working with them, and the theoretical computational background. Therefore, I will not try and answer this question in a single phrase; my explanation of what Monads are is the entirety of this paper.</p>
<p>I would like to take a few moments and clear up one possible misconception. Monads are not special. They are a data structure, just like a Linked List or a Dictionary. They have methods that you can call, and they store data in the same way. They don't have a common sounding name, so they seem scary, and people have a tendency to define them using complex math or weird analogies, but I firmly believe that Monads aren't actually any more complicated than the run of the mill data structures that programmers use every day.</p>
<h1 id="our-first-monads"><span class="header-section-number">2</span> Our First Monads</h1>
<p>In this section, we'll explore a common problem surrounding how to report errors to the caller of a function.</p>
<h2 id="error-handling-in-plain-python"><span class="header-section-number">2.1</span> Error Handling in Plain Python</h2>
<p>Python usually uses Exception raising and catching to report errors that happen within code. It's a desirable feature to have in a scripting language, but it is less useful in systems languages, like C, Go, or Rust, because exceptions are expensive in terms of memory and CPU time. It's also less useful in functional languages like Haskell or Scala, which use types and abstract data structures to make code more predictable and safer, a goal which is undermined when code can throw exceptions that crash the whole program. In the following section, I'll be exploring ways to handle errors in Python without throwing exceptions and without using Monads.</p>
<h3 id="division"><span class="header-section-number">2.1.1</span> Division</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> division(x, y):
    <span class="cf">return</span> x <span class="op">/</span> y</code></pre></div>
<p>Consider the above code fragment. This is a very simple function; one that is so simple it hardly deserves to exist. However, if <code>y</code> is zero, this function can throw a <code>ZeroDevisionError</code>. It's possible that we want to recover from this error gracefully; check the inputs and see if an error will occur, and return some error code instead of raising an exception.</p>
<p>However, we must decide what the error code should be. We can't choose <code>0.0</code>, because that is correctly returned by <code>division(0.0,1.0)</code>. We can't choose <code>-1.0</code>, because that is correctly returned by <code>division(-1.0,1.0)</code>. In fact, this function can return any possible floating point number, so we can't choose a floating point number as our error code. One solution is to return a float on success, but <code>None</code> on failure.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> division(x, y):
    <span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> <span class="va">None</span>
    <span class="cf">return</span> x <span class="op">/</span> y</code></pre></div>
<p>Now we've written a function that checks whether or not division is possible, and performs division if it is, but returns an error code if it is not.</p>
<h3 id="indexing"><span class="header-section-number">2.1.2</span> Indexing</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> index(ls, i):
    <span class="cf">return</span> ls[i]</code></pre></div>
<p>The above code is similar to the last example; it will perform an index lookup into a list, and return the item from the list if it can. If it can't, we're still left with the problem that it throws an exception if the index is out of bounds. Let's try and do the same thing as above; rewrite this function so that it doesn't throw an error, but instead uses an error code to signal something has gone wrong.</p>
<p>Our first guess might be to have our error code be the same as above, and just return <code>None</code>. However, this isn't possible, because the code <code>index([None], 0)</code> would also return <code>None</code>. In fact, python lets any value be inside of a list; there is no possible error code we can return that can't also be in the list. Luckily, python lets us use multiple return values.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> <span class="va">True</span>, <span class="va">None</span>
    <span class="cf">return</span> <span class="va">False</span>, ls[i]</code></pre></div>
<p>This allows us to actually check whether or not this function has failed, without worrying about receiving an exception. This allows us to handle errors from outside of the function in a logical way:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">failed, value <span class="op">=</span> index([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],<span class="dv">0</span>)
<span class="cf">if</span> failed:
    <span class="bu">print</span>(<span class="st">&quot;Oh no, we failed&quot;</span>)
<span class="cf">else</span>:
    <span class="bu">print</span>(value)</code></pre></div>
<h3 id="combining-the-above"><span class="header-section-number">2.1.3</span> Combining The Above</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> divide_elements(ls, i1, i2):
    <span class="cf">return</span> ls[i1]<span class="op">/</span>ls[i2]</code></pre></div>
<p>Now, we've combined the two operations in python which might lead to an exception, and we've done it in a way that allows for three different operations to result in an exception. We can rewrite this function so that it won't throw any errors, by checking after each step for an error code.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> <span class="va">True</span>, <span class="va">None</span>
    <span class="cf">return</span> <span class="va">False</span>, ls[i]

<span class="kw">def</span> division(x, y):
    <span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> <span class="va">None</span>
    <span class="cf">return</span> x <span class="op">/</span> y

<span class="kw">def</span> divide_elements(ls, i1, i2):
    failure, v1 <span class="op">=</span> index(ls, i1)
    <span class="cf">if</span> failure:
        <span class="cf">return</span> <span class="va">None</span>
    
    failure, v2 <span class="op">=</span> index(ls, i2)
    <span class="cf">if</span> failure:
        <span class="cf">return</span> <span class="va">None</span>
    
    <span class="cf">return</span> division(v1, v2)</code></pre></div>
<p>This code works nicely; you can throw two types of errors at it, and it returns <code>None</code> when either error would occur.</p>
<h3 id="other-programming-languages"><span class="header-section-number">2.1.4</span> Other Programming Languages</h3>
<p>Python has been very nice to us so far; in Python, it is easy to write a function that returns two values, or returns different types in different scenarios. Python also has other features, such as Exceptions, which make this rewriting we've been dong sort of useless. The most Pythonic way of writing the above would probably be to catch the exceptions, writing:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> divide_elements(ls, i1, i2):
    <span class="cf">try</span>:
        <span class="cf">return</span> ls[i1]<span class="op">/</span>ls[i2]
    <span class="cf">except</span> (<span class="pp">IndexError</span>, <span class="pp">ZeroDivisionError</span>):
        <span class="cf">return</span> <span class="va">None</span></code></pre></div>
<p>Other languages have their own ways of dealing with the errors we discussed above, and they all have their own benefits. In C, the common pattern is to have the actual return value of the function be a number that indicates whether an error occurred, and if one did, what the error was. To get the meaningful result from the function, you pass a pointer to a block of memory into the function, and that function writes the answer you want into that block of memory. This is much faster and simpler than having to write all of the infrastructure required to deal with throwing exceptions and allowing someone above you to catch that exception.</p>
<p>In many modern languages, including Rust, Scala, and Haskell, the solution of choice is to use Monads.</p>
<h2 id="the-option-monad"><span class="header-section-number">2.2</span> The Option Monad</h2>
<p>The Option Monad, also called the Maybe Monad in many programming languages, is a way of representing the result of a function or computation that might result in an error and produce no meaningful output. We call an Option Monad that has a value and represents a successful computation Some, and we call one that doesn't have a value and represents a failed computation Nothing.</p>
<p>These are really easy to write in programming languages like Haskell, Scala, or Rust, but I'm going to write it in Python to help avoid any confusion about the inner workings of the Monad. In the end, all Monads are just objects, like trees, lists, or dictionaries.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Option:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._value <span class="op">=</span> value

    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Nothing&#39;</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Some({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._value)
            
    <span class="kw">def</span> is_some(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="va">False</span>
        <span class="cf">return</span> <span class="va">True</span>

    <span class="kw">def</span> is_none(<span class="va">self</span>):
        <span class="cf">return</span> <span class="op">not</span> <span class="va">self</span>.is_some()

    <span class="kw">def</span> unwrap(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Option has no value&#39;</span>)
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">self</span>._value
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> some(cls, x):
        <span class="cf">return</span> cls(<span class="va">False</span>, x)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> none(cls):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>)</code></pre></div>
<p>This is the longest piece of code we've had so far, so let me break it down bit by bit.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Option:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._value <span class="op">=</span> value
    
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Nothing&#39;</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Some({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._value)</code></pre></div>
<p>The <code>__init__</code> function is the constructor or initializer function for classes in python. Here all we do is create a boolean that indicates whether or not we have failed the computation or not, and if we haven't failed it, we store the result of the computation in <code>_value</code>. Note that if <code>_failed</code> is <code>True</code>, then we don't care what is in <code>_value</code>, because the computation has failed and that value has no meaning. I will note that the users of this class will probably never call <code>__init__</code> themselves, as we will later write alternate constructors that are easier for people to use.</p>
<p>The <code>__repr__</code> function simply tells python how this object should be printed.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> is_some(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="va">False</span>
        <span class="cf">return</span> <span class="va">True</span>
        
    <span class="kw">def</span> is_none(<span class="va">self</span>):
        <span class="cf">return</span> <span class="op">not</span> <span class="va">self</span>.is_some()

    <span class="kw">def</span> unwrap(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Option has no value&#39;</span>)
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">self</span>._value</code></pre></div>
<p>These three functions are the meat of the Option Monad; these are the ways we interact with it. The <code>is_some</code> function returns <code>True</code> when there is a meaningful return value, and <code>False</code> if the computation failed. <code>is_none</code> does the opposite. <code>unwrap</code> returns the value of the Option Monad <em>if there is a value to be returned</em>, otherwise it throws an error. In order to use the <code>unwrap</code> function without an error, you must first check and see whether the computation succeeded or failed.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="at">@classmethod</span>
    <span class="kw">def</span> some(cls, x):
        <span class="cf">return</span> cls(<span class="va">False</span>, x)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> none(cls):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>)</code></pre></div>
<p>These functions, decorated with <code>@classmethod</code>, aren't methods of the object. Instead, they're methods that exist as part of the class itself; here, we use them as alternate constructors.</p>
<p>At this point, let me rewrite our exception-free code from above using the Option Monad.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> division(x, y):
    <span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(x <span class="op">/</span> y)

<span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(ls[i])

<span class="kw">def</span> divide_elements(ls, i1, i2):
    res1 <span class="op">=</span> index(ls, i1)
    <span class="cf">if</span> res1.is_none():
        <span class="cf">return</span> Option.none()
    
    res2 <span class="op">=</span> index(ls, i2)
    <span class="cf">if</span> res2.is_none():
        <span class="cf">return</span> Option.none()
    
    <span class="cf">return</span> division(res1.unwrap(), res2.unwrap())</code></pre></div>
<p>The above code is the exact same length in lines; and already has some benefits. First, these functions have a return type that can be determined just be looking at the code - not as useful in python as in other languages, but they are very useful in statically typed languages. Second, we don't have to remember the convention for every function. Before, we had to remember that <code>division</code> returned <code>None</code> for an error, but <code>index</code> returned <code>False, None</code> for an error. Despite these benefits, it's not that much of an improvement.</p>
<p>And that's because we haven't yet implemented the most important function for a Monad. This is the most important but also the most complicated part of the Option Monad, so I am going to insert a header for this.</p>
<h2 id="the-bind-and-fmap-functions"><span class="header-section-number">2.3</span> The Bind and Fmap Functions</h2>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_none():
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="cf">return</span> function(val)</code></pre></div>
<p>The bind function is higher order function. That means it's a function that takes another function as an argument, and does something with that function. If you look in the end of the previous section, we repeated this piece of code two times:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    res <span class="op">=</span> index(ls, i1)
    <span class="cf">if</span> res.is_none():
        <span class="cf">return</span> Option.none()</code></pre></div>
<p>We were checking whether or not a function had successfully computed a value, or whether an error had occurred. If the value existed, we later passed that value into a function. If the value did not exist, then we simply returned the indication of failure, an <code>Option.none()</code> object.</p>
<p>Looking at bind, we can see it does exactly that. <code>res.bind(function)</code> checks whether or not <code>res</code> is a successfully computed value, in which case it passes that value into <code>function</code>, or if it is a failed computation, in which case it simply returns itself, passing the failed computation forward.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_none():
            <span class="cf">return</span> <span class="va">self</span>

        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="cf">return</span> Option.some(function(val))</code></pre></div>
<p><code>fmap</code> does something similar to <code>bind</code>; whereas the function passed to <code>bind</code> might fail, and therefore returns an Option Monad, a function passed to <code>fmap</code> will always succeed, and therefore the return value needs to be wrapped in an Option Monad again. <code>fmap</code> and <code>bind</code> serve very similar purposes, but they are useful in different contexts.</p>
<p>So, with <code>fmap</code> and <code>bind</code> in mind, let's consider the our code again.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> division(x, y):
    <span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(x <span class="op">/</span> y)

<span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(ls[i])

<span class="kw">def</span> divide_elements(ls, i1, i2):
    res1 <span class="op">=</span> index(ls, i1)
    res2 <span class="op">=</span> index(ls, i2)
    
    partial <span class="op">=</span> <span class="kw">lambda</span> x: <span class="kw">lambda</span> y: division(x,y)
    
    <span class="cf">return</span> res2.bind(res1.bind(partial))</code></pre></div>
<p>I've changed a few things, so go back and look at what I've done. There's this new line <code>partial = lambda x: lambda y: division(x,y)</code>. This is a way of defining an inline function in python; here, I have a function of x that returns a function of y, that itself returns <code>division(x,y)</code>. This makes it so that instead of calling this function with two arguments, I instead call it with one argument twice. Here's an example of using a similar lambda function:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">partial <span class="op">=</span> <span class="kw">lambda</span> x: <span class="kw">lambda</span> y: x<span class="op">/</span>y

two_over <span class="op">=</span> partial(<span class="dv">2</span>)
two_over(<span class="dv">3</span>) <span class="co"># same as 2 / 3</span>
two_over(<span class="dv">5</span>) <span class="co"># same as 2 / 5</span>

ten_over <span class="op">=</span> partial(<span class="dv">10</span>)
ten_over(<span class="dv">50</span>) <span class="co"># same as 10 / 50</span>

partial(<span class="dv">3</span>)(<span class="dv">4</span>) <span class="co"># same as 3 / 4</span></code></pre></div>
<p>What I do on the return statement line is I use bind to apply the function to these arguments; the function <code>division</code> will fail drastically if it gets an Option Monad in as an argument; it would fail on the comparison to zero and it would also fail on trying to divide two Option Monads. By using <code>bind</code>, I am telling the Options to apply the function to themselves if they have a value, or returning Nothing if they don't have a value. This wraps the error handling into the data structure that represents errors without me having to ever write an explicit <code>if x.is_some():</code> check.</p>
<p>You may still think this sort of thing is useless; and in python, for such a simple example, it kinda is! But as we continue to explore Monads, we will encounter some examples of things that get more and more complex without Monads, but that Monads make simpler. Oh hey look, that's the next section.</p>
<h2 id="a-more-complex-example"><span class="header-section-number">2.4</span> A More Complex Example</h2>
<p>In order to give a more illustrative example of where the Option Monad can be more useful, consider the following problem; open a file, and read the first whitespace separated word from the beginning of the file, and parse it into an integer if possible. This problem is fairly easy to do with built in Python functions, but the Option Monad can make error handling easier. However, none of Python's built in functions use the Option Monad, so we will have to rewrite them so that they do. In languages with the Option Monad as a star player, such as Rust, Haskell, or Scala, this isn't an issue.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> option_open(filename, mode<span class="op">=</span><span class="st">&#39;r&#39;</span>):
    <span class="cf">try</span>:
        fd <span class="op">=</span> Option.some(<span class="bu">open</span>(filename, mode<span class="op">=</span>mode))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        fd <span class="op">=</span> Option.none()
    <span class="cf">return</span> fd

<span class="kw">def</span> option_read(fd, size<span class="op">=-</span><span class="dv">1</span>):
    <span class="cf">try</span>:
        data <span class="op">=</span> Option.some(fd.read(size))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        data <span class="op">=</span> Option.none()
    <span class="cf">return</span> data

<span class="im">import</span> re

<span class="kw">def</span> option_match(pattern, string):
    match <span class="op">=</span> re.match(pattern, string)
    <span class="cf">if</span> match:
        match <span class="op">=</span> Option.some(match)
    <span class="cf">else</span>:
        match <span class="op">=</span> Option.none()
    <span class="cf">return</span> match

<span class="kw">def</span> option_get_group(match, group):
    <span class="cf">try</span>:
        g <span class="op">=</span> match.group(group)
    <span class="cf">except</span> <span class="pp">Exception</span>:
        g <span class="op">=</span> <span class="va">None</span>

    <span class="cf">if</span> g <span class="op">==</span> <span class="va">None</span>:
        g <span class="op">=</span> Option.none()
    <span class="cf">else</span>:
        g <span class="op">=</span> Option.some(g)
    
    <span class="cf">return</span> g

<span class="kw">def</span> option_int(s):
    <span class="cf">try</span>:
        i <span class="op">=</span> Option.some(<span class="bu">int</span>(s))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        i <span class="op">=</span> Option.none()

    <span class="cf">return</span> i</code></pre></div>
<p>These functions perform the exact same operations as their Python counterparts, but they return Some if the computation succeeds and Nothing if it fails, instead of throwing an error or using some other return code. This will allow us to use <code>bind</code> to chain these functions.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">result <span class="op">=</span> (Option.some(<span class="st">&#39;text.txt&#39;</span>)
    .bind(option_open)
    .bind(option_read)
    .bind(<span class="kw">lambda</span> x: option_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
    .bind(<span class="kw">lambda</span> x: option_get_group(x, <span class="dv">1</span>))
    .bind(option_int))</code></pre></div>
<p>This code opens a text file, reads the entire file from it, looks at the first word in the file, and tries to read it in as an integer. Using the Option Monad is useful because if an error happens at any time during the computation, it just passes a Nothing Option through the rest of the bind functions.</p>
<p>We can make this look cooler by choosing an infix operator to overload. By convention, <code>&gt;&gt;=</code> is used, but that's hard to to do in python, so we are going to use <code>&gt;&gt;</code>. We can override that operator in python with the following code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> <span class="fu">__rshift__</span>(<span class="va">self</span>, function):
    <span class="cf">return</span> <span class="va">self</span>.bind(function)</code></pre></div>
<p>Now, let's rewrite the above option code as the following.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">result <span class="op">=</span> (
    Option.some(<span class="st">&#39;text.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> option_open
      <span class="op">&gt;&gt;</span> option_read
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_get_group(x, <span class="dv">1</span>))
      <span class="op">&gt;&gt;</span> option_int
    )</code></pre></div>
<p>Consider the same operation in regular Python. We can write it in one expression, in which case this is impossible to read, or we can split it up, over many lines, creating a bunch of temporary variables that we use once and then never again.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># one expression</span>
result <span class="op">=</span> <span class="bu">int</span>(
        re.match(
            <span class="vs">r&#39;\s*(\S*)&#39;</span>,
            <span class="bu">open</span>(<span class="st">&#39;text.txt&#39;</span>).read()
        ).group(<span class="dv">1</span>)
    )

<span class="co"># with temporary variables</span>
temp1 <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;text.txt&#39;</span>).read()
temp2 <span class="op">=</span> re.match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, temp1).group(<span class="dv">1</span>)
result <span class="op">=</span> <span class="bu">int</span>(temp2)</code></pre></div>
<p>The first example is unreadable. The functions used have no meaningful order, so it becomes an act of mental gymnastics to figure out what happens when. The functions appear in the order <code>int</code>, <code>match</code>, <code>open</code>, <code>read</code>, and <code>group</code>. <code>int</code> comes first, despite being called last, and <code>open</code>, the first function to be called, appears randomly in the middle.</p>
<p>The second example is the shortest version where all the functions appear in the source code in the order they are called, and so it is pretty readable, but once again we've got the problem of errors!</p>
<p>This code could blow up if the wrong information is passed into it, and it can blow up in approximately 5 places. Even worse, because <code>.group()</code> can return <code>None</code> if it fails, and <code>int(None) == 0</code>, you can get a wrong answer from this code without an error being thrown. In order to guarantee that this code doesn't fail, this is the sort of code you would need to write in Python.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
    temp1 <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;text.txt&#39;</span>).read()
    temp2 <span class="op">=</span> re.match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, temp1).group(<span class="dv">1</span>)
    <span class="cf">if</span> temp2 <span class="op">==</span> <span class="va">None</span>:
        result <span class="op">=</span> <span class="va">None</span>
    <span class="cf">else</span>:
        result <span class="op">=</span> <span class="bu">int</span>(temp2)
<span class="cf">except</span> <span class="pp">Exception</span>:
    result <span class="op">=</span> <span class="va">None</span></code></pre></div>
<p>The above code now won't throw any errors or produce erroneous results, and will set <code>result</code> to <code>None</code> if the code fails. Now, compare that safe version without Monads to the version that is safe with Monads.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">result <span class="op">=</span> (
    Option.some(<span class="st">&#39;text.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> option_open
      <span class="op">&gt;&gt;</span> option_read
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_get_group(x, <span class="dv">1</span>))
      <span class="op">&gt;&gt;</span> option_int
    )</code></pre></div>
<p>The Monad version is simpler, just as safe, and even a line shorter (two if you don't count the line with a single closing parenthesis). Not to mention cooler by far.</p>
<h2 id="the-result-monad"><span class="header-section-number">2.5</span> The Result Monad</h2>
<p>There is one major problem with the Option monad above; if our code fails, we have no way to know how or when. With the standard python example, we could print an error message to the screen or to a file that would let us know what kind of error occurred. There is another Monad, called the Result Monad, that allows us to do that while still having the power of the Option Monad. I won't reproduce the entire code here (it is in the appendix) but I will go over a few of the changes, as we will use the Result Monad in the next section.</p>
<p>The Result Monad uses slightly different names; a value is Ok if it is a successful computation, and it is an Error if it has failed. The functions to check this status are <code>self.is_ok()</code> and <code>self.is_error()</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value, message):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._message <span class="op">=</span> message
        <span class="va">self</span>._value <span class="op">=</span> value</code></pre></div>
<p>Our <code>__init__</code> function now takes an additional argument; an error message. Now, we have a value that indicates whether or not our computation has failed, a value that stores the result of the computation (if the computation succeeded), and a value that stores the error message (if the computation failed).</p>
<p>In order to access the error message, we add a new function like <code>unwrap</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> error_msg(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>._message
        <span class="cf">else</span>:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Result is Ok&#39;</span>)</code></pre></div>
<p>This function checks whether or not we have failed, and returns the error message if it is an Error. Just like <code>unwrap</code>, it throws an Exception if there is no error message.</p>
<p><code>bind</code> has not changed at all, but it is nice to note that when you return <code>self</code> in the case of the error, the error message stays the same.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="cf">return</span> function(val)</code></pre></div>
<p>I'm also adding another function that is sort of like <code>bind</code>, but instead, provides a simple way for Monadic computations to check for errors, and if they've occurred, to replace the computed value with a default value.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> recover(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> function()
        
        <span class="cf">return</span> <span class="va">self</span></code></pre></div>
<p>This function allows you to perform an operation like getting a value from a configuration file, but using a default value if it fails, with Monads. The following snippet, for example, uses results to open, read, and parse some number from a file, and then it checks whether the operation failed at any level, and uses the value of <code>10</code> if it failed.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">config <span class="op">=</span> (
    result_open(<span class="st">&#39;config.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> result_read
      <span class="op">&gt;&gt;</span> result_parse
    ).recover(<span class="kw">lambda</span>: Result.ok(<span class="dv">10</span>))</code></pre></div>
<p>The equivalent in plain Python would be the following.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
    temp1 <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;config.txt&#39;</span>).read()
    config <span class="op">=</span> parse(temp1)
<span class="cf">except</span> <span class="pp">Exception</span>:
    config <span class="op">=</span> <span class="dv">10</span></code></pre></div>
<p>We've already seen these used above, but for completeness here are the two constructors for the Result Monad.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="at">@classmethod</span>
    <span class="kw">def</span> ok(cls, val):
        <span class="cf">return</span> cls(<span class="va">False</span>, val, <span class="va">None</span>)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> error(cls, msg):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>, msg)</code></pre></div>
<h1 id="a-parsing-monad"><span class="header-section-number">3</span> A Parsing Monad</h1>
<p>We're now going to talk about a Monad called the Parsing Combinator, which basically recreates and improves upon regular expressions using Monads. Here we see the truth of the oft said but little understood aphorism that Monads represent computation; here, they represent the computation of regular expressions.</p>
<p>It's also worth noting that there are many python Parsing Combinator libraries on the python package index, and those will have faster, more powerful implementations than the one below.</p>
<h2 id="the-code"><span class="header-section-number">3.1</span> The Code</h2>
<p>Unlike the Option Monad, I'm not going to go over the entire codebase for the Parsing Combinator. I hope to provide enough context so that the inner workings aren't mysterious, but there is a lot of code (all in the appendix) and it is frankly quite dull at times.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Parser:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, function):
        <span class="va">self</span>._function <span class="op">=</span> function
        
    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, text, index):
        <span class="cf">return</span> <span class="va">self</span>._function(text, index)</code></pre></div>
<p>The basic idea behind our Parsing Combinator is that the Monad holds a function that takes a string, which we're going to call <code>text</code>, and it returns a Result Monad. If the result is a success, the Result Monad holds a tuple of the text that has matched the current parser, and the remainder of <code>text</code>. In order to make this a bit easier for us, we will implement the special method <code>__call__</code>, so that we can write stuff like <code>self(text)</code> instead of <code>self._function(text)</code> in the future.</p>
<p>Before we jump into all of the super complex functions, let's look at a basic constructor for this Parser Monad.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="at">@classmethod</span>
    <span class="kw">def</span> char(cls, val):

        <span class="kw">def</span> match_char(text):
            <span class="cf">try</span>:
                current <span class="op">=</span> text[<span class="dv">0</span>]
            <span class="cf">except</span> <span class="pp">IndexError</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but &#39;</span> <span class="op">+</span>
                    <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(val)))
            
            <span class="cf">if</span> current <span class="op">==</span> val:
                <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to match character {} at {}&#39;</span>
                    .<span class="bu">format</span>(<span class="bu">repr</span>(val), <span class="bu">repr</span>(text)))

        <span class="cf">return</span> Parser(match_char)</code></pre></div>
<p>This constructor creates a Parser with the function <code>match_char</code>. If we look at <code>match_char</code>, despite its length, it is a very simple function. First, it tries to see what the first character in the string (<code>current</code>) is, checking for an error (and returning an Error Result Monad) if there is one. Then, it compares <code>current</code> to the value that was passed into the constructor, and sees if it matches. If it does match, then it returns an Ok Result, with the parsed value being the character, and the remaining text being the rest of the text, from the parsed character on.</p>
<p>Now that we've seen a way to construct this Monad, let's look at how to combine simple Parsing Combinators into more complex ones.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> combine(<span class="va">self</span>, other, function):
        
        <span class="kw">def</span> combine_func(match, rest):
            res <span class="op">=</span> other(rest)
            <span class="cf">if</span> res.is_ok():
                other_match, rest <span class="op">=</span> res.unwrap()
                new_match <span class="op">=</span> function(match, other_match)
                <span class="cf">return</span> Result.ok((new_match, rest))
            <span class="cf">else</span>:
                <span class="cf">return</span> res
            
        <span class="cf">return</span> (
              Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text)
                .bind(<span class="kw">lambda</span> res: combine_func(<span class="op">*</span>res)))
            )</code></pre></div>
<p><code>combine</code> is the most useful function for us; it takes two parsers (<code>self</code> and <code>other</code>) and a function. It creates a new parser that first executes <code>self</code> on the input text, and then it executes <code>other</code> on the remaining text after <code>self</code>'s match. Then it uses <code>function</code> to combine the two matches, and returns that combination along with the remaining text. We're also going to define a few functions that call combine with a particular function.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> concat(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: x <span class="op">+</span> y)
        
    <span class="kw">def</span> first(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: x)
    
    <span class="kw">def</span> last(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: y)
    
    <span class="kw">def</span> <span class="bu">tuple</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: (x,y))</code></pre></div>
<p>These functions are the most common choices for what you might want to use to combine the two matches. Most common is <code>concat</code>, which simply concatenates the two strings; this is the default regex behavior. Then there is <code>first</code> and <code>last</code>, which instead of combining the two values, instead discard one of the values. We will see later why this is useful. Finally, we can put the two values into a tuple instead of concatenating them. This is mostly useful when used in conjunction with <code>bind</code>, which we will discuss later. However, I've provided a few examples of working with these functions.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">match_a <span class="op">=</span> Parser.char(<span class="st">&#39;a&#39;</span>)
match_b <span class="op">=</span> Parser.char(<span class="st">&#39;b&#39;</span>)

<span class="co"># This will match the string &#39;ab&#39; and return the string &#39;ab&#39;</span>
match_a.concat(match_b)

<span class="co"># This will match the string &#39;ab&#39; and return the string &#39;a&#39;</span>
match_a.first(match_b)

<span class="co"># This will match the string &#39;ab&#39; and return the string &#39;b&#39;</span>
match_a.last(match_b)

<span class="co"># This will match the string &#39;ab&#39; and return the tuple (&#39;a&#39;,&#39;b&#39;)</span>
match_a.<span class="bu">tuple</span>(match_b)</code></pre></div>
<p>We also have a few other important functions that we use to build more complex parsers. I haven't included their code here, because I think that understanding <code>combine</code> is the most important code here, and I don't want to get bogged down in too many details.</p>
<p><code>choice</code> implements the ability to try one parser, and if it fails, recover by trying another. Be careful with this one, because it only operates locally. If you try and match <strong>x</strong> or <strong>y</strong>, and <strong>x</strong> succeeds in matching the text but puts you in a corner that causes failure later on, it won't backtrack and try <strong>y</strong>. It will only backtrack and try <strong>y</strong> if matching <strong>x</strong> fails.</p>
<p><code>many</code> is perhaps the most complicated constructor. What we want to do is continually match one parser, using a function to combine the results, until a failure occurs; but when a failure occurs, we want to ignore the failure and return that previous match. We also implement <code>many1</code> that matches one or more examples of an object, not zero or more like <code>many</code>.</p>
<p>There is also a variant of <code>many</code> called <code>many_list</code>, which instead of combining them by concatenating them, like <code>many</code> does, simply collects a list of all of the many matches.</p>
<p>Finally, <code>optional</code> tries to match the input text with <code>self</code>, but if it fails, it matches nothing and finishes.</p>
<p>Finally, we add symbolic versions of many of the above functions. This is purely for ease of reading the expressions we will write; you will see that they can get pretty complex, and <code>this.concat(that)</code> is harder to understand at a glance than <code>this + that</code>.</p>
<p>Now we can move on to the Monadic functions.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        
        <span class="kw">def</span> bind_func(result):
            function(result[<span class="dv">0</span>]).bind(<span class="kw">lambda</span> x:
                Result.ok(x, result[<span class="dv">1</span>]))

        <span class="cf">return</span> Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text).bind(bind_func))</code></pre></div>
<p><code>bind</code> is, of course, the star of the show. Lets break this down into steps, starting from the the return statement and moving back.</p>
<ul>
<li>We're creating a new Parser, so we're passing in a function that takes text, and should return a Result Monad holding <code>(matched value, remainder of text)</code>.</li>
<li>The first thing this function does is pass <code>text</code> through the current parser's function. This should result in a Result Monad holding <code>(matched value, remainder of text)</code>.</li>
<li>Then, we call bind on that result, passing in <code>bind_func</code>. <code>bind_func</code> is going to get a tuple as it's only argument, and should return a Result Monad holding <code>(matched value, remainder of text)</code>.</li>
<li><code>bind_func</code> takes the result, and passes the matched value through the function passed in to the Parser's bind function. This gives us a Result Monad, and we pull out it's value (if it exists).</li>
<li>Then we build the new Result Monad holding <code>(matched value, remainder of text)</code>, except now the matched value is the result of <code>function</code>.</li>
</ul>
<p>We're also going to use <code>bind</code> to define <code>fmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bind(<span class="kw">lambda</span> x: Result.ok(function(x)))</code></pre></div>
<p>The high level understanding of <code>bind</code> and <code>fmap</code> comes from the view of the Parsing Combinator as holding both an already parsed value, and the remainder of the string to be parsed. <code>bind</code> and <code>fmap</code> operate on the already parsed value, and don't alter the remaining string to be parsed.</p>
<p>Here is a full table of which functions I have bound to which symbols:</p>
<table>
<thead>
<tr class="header">
<th align="right">symbol</th>
<th>function</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right"><code>+</code></td>
<td><code>concat</code></td>
<td>concatenates the parsed values</td>
</tr>
<tr class="even">
<td align="right"><code>&lt;=</code></td>
<td><code>first</code></td>
<td>returns the parsed value of the first parser</td>
</tr>
<tr class="odd">
<td align="right"><code>=&gt;</code></td>
<td><code>last</code></td>
<td>returns the parsed value of the last parser</td>
</tr>
<tr class="even">
<td align="right"><code>&amp;</code></td>
<td><code>tuple</code></td>
<td>returns the parsed value of both parsers in a tuple</td>
</tr>
<tr class="odd">
<td align="right"><code>&gt;&gt;</code></td>
<td><code>bind</code></td>
<td>applies the function to the parsed value</td>
</tr>
<tr class="even">
<td align="right"><code>&gt;</code></td>
<td><code>fmap</code></td>
<td>applies the function to the parsed value</td>
</tr>
<tr class="odd">
<td align="right"><code>|</code></td>
<td><code>choice</code></td>
<td>tries the first parser, and if it fails, tries the second</td>
</tr>
</tbody>
</table>
<p>There are also many constructors available, so here's a list of them and a brief description of what they do.</p>
<table>
<thead>
<tr class="header">
<th>constructor</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char</code></td>
<td>Matches the character that is passed into it</td>
</tr>
<tr class="even">
<td><code>oneof</code></td>
<td>Matches any one of the characters passed in as a string or list</td>
</tr>
<tr class="odd">
<td><code>empty</code></td>
<td>Matches nothing</td>
</tr>
<tr class="even">
<td><code>noneof</code></td>
<td>Matches any character not passed in as a string or list</td>
</tr>
</tbody>
</table>
<h2 id="using-the-parser-combinator"><span class="header-section-number">3.2</span> Using the Parser Combinator</h2>
<p>Now we have a powerful enough Parser Monad to recreate all of the flexibility and power of regular expressions. We can combine parsers to make more complex ones, we can define functions that return parsers that recreate common regular expressions syntax, so let's try parsing something simple; let's try and write a Parser Combinator that parses numbers.</p>
<p>A number can be as simple as <code>12</code> or as complex as <code>12.00123e45</code>, so we're going to need to build up a complex parser. Let's start with creating a parser that parses 1 or more of consecutive digits.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">digits <span class="op">=</span> Parser.oneof(<span class="st">&#39;0123456789&#39;</span>).many1()</code></pre></div>
<p>Now, we need to express an optional decimal place, followed by one of more digits. Remember, the <code>+</code> will parse one, and then the other, and then concatenate their results.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">decimal <span class="op">=</span> (Parser.char(<span class="st">&#39;.&#39;</span>) <span class="op">+</span> digits).optional()</code></pre></div>
<p>Now, we need an exponent part, which is pretty simple given the above. However, we do need one additional component, a sign. The <code>|</code> symbol will parse one or the other of the two things on either side of it.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">sign <span class="op">=</span> (Parser.char(<span class="st">&#39;+&#39;</span>) <span class="op">|</span> Parser.char(<span class="st">&#39;-&#39;</span>)).optional()
exponent <span class="op">=</span> ((Parser.char(<span class="st">&#39;e&#39;</span>) <span class="op">|</span> Parser.char(<span class="st">&#39;E&#39;</span>))
             <span class="op">+</span> sign <span class="op">+</span> digits).optional()</code></pre></div>
<p>Finally, we can put these three together to get:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">number <span class="op">=</span> sign <span class="op">+</span> digits <span class="op">+</span> decimal <span class="op">+</span> exponent</code></pre></div>
<p>Here's our finished code, and it's results on some possible inputs:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">digits <span class="op">=</span> Parser.oneof(<span class="st">&#39;0123456789&#39;</span>).many1()
decimal <span class="op">=</span> (Parser.char(<span class="st">&#39;.&#39;</span>) <span class="op">+</span> digits).optional()
sign <span class="op">=</span> (Parser.char(<span class="st">&#39;+&#39;</span>) <span class="op">|</span> Parser.char(<span class="st">&#39;-&#39;</span>)).optional()
exponent <span class="op">=</span> ((Parser.char(<span class="st">&#39;e&#39;</span>) <span class="op">|</span> Parser.char(<span class="st">&#39;E&#39;</span>))
            <span class="op">+</span> sign <span class="op">+</span> digits).optional()
number <span class="op">=</span> sign <span class="op">+</span> digits <span class="op">+</span> decimal <span class="op">+</span> exponent

Parser.parse_total(number, <span class="st">&#39;12&#39;</span>)
    <span class="co"># Ok(&#39;12&#39;)</span>
Parser.parse_total(number, <span class="st">&#39;12e10&#39;</span>)
    <span class="co"># Ok(&#39;12e10&#39;)</span>
Parser.parse_total(number, <span class="st">&#39;2.12345e100&#39;</span>)
    <span class="co"># Ok(&#39;2.12345e100&#39;)</span>
Parser.parse_total(number, <span class="st">&#39;hello world&#39;</span>)
    <span class="co"># Error(Failed to match one of</span>
    <span class="co"># [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;])</span>
Parser.parse_total(number, <span class="st">&#39;99 bottles of beer on the wall&#39;</span>)
    <span class="co"># Error(The match did not consist of the entire string:</span>
    <span class="co"># &#39; bottles of beer on the wall&#39; was left over)</span>
Parser.parse_total(number, <span class="st">&#39;&#39;</span>)
    <span class="co"># Error(End of String encountered)</span></code></pre></div>
<p>Furthermore, we can use a result-oriented version of python's <code>float</code> function, along with our <code>bind</code> operator, to cast these results to be floats instead of strings.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> result_float(x):
    <span class="cf">try</span>:
        <span class="cf">return</span> Result.ok(<span class="bu">float</span>(x))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to cast to a float&#39;</span>)

Parser.parse_total(number, <span class="st">&#39;7.22345e10&#39;</span>) <span class="op">&gt;&gt;</span> result_float
    <span class="co"># Ok(72234500000.0)</span></code></pre></div>
<h2 id="going-further"><span class="header-section-number">3.3</span> Going Further</h2>
<p>Everything we've done so far can basically be done in the exact same way by regular expressions. However, because of the way we've defined the Parsing Combinator, we can use <code>bind</code> and <code>fmap</code> inside of Parsing Combinator expressions. This allows us to parse complex expressions into fully formed and entirely arbitrary python objects.</p>
<h3 id="list-of-numbers-parser"><span class="header-section-number">3.3.1</span> List of Numbers Parser</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">number <span class="op">=</span> (sign <span class="op">+</span> digits <span class="op">+</span> decimal <span class="op">+</span> exponent) <span class="op">&gt;&gt;</span> result_float</code></pre></div>
<p>As above, we can put the cast to a float inside of the number parser, and it will automatically do the conversion whenever something is parsed. We can also take this further:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">whitespace <span class="op">=</span> Parser.oneof(<span class="st">&#39; </span><span class="ch">\n</span><span class="st">&#39;</span>).many1()

<span class="co"># without infix operators</span>
many_numbers <span class="op">=</span> (
    (whitespace.optional().last(number))
    ).many_list()

<span class="co"># with infix operators</span>
many_numbers <span class="op">=</span> (
        (whitespace.optional() <span class="op">&gt;=</span> number)
    ).many_list()</code></pre></div>
<p>Let me take this text and expand it into English. This reads 'If there's any whitespace, match it and discard it, and parse a number following it. Then, put that number in a list, and repeat until parsing fails. Then combine all of the lists (via concatenation), and return that.' And this works perfectly, in pure and standard python, with no <code>eval</code> or <code>exec</code> statements. And it is simpler than doing this with regular expressions.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">text <span class="op">=</span> <span class="st">&#39;2.12345e+100 2.1e10 1223 13.5 100e100&#39;</span>
<span class="bu">print</span>(Parser.parse_total(many_numbers, text))
<span class="co"># Ok([2.12345e+100, 21000000000.0, 1223.0, 13.5, 1e+102])</span></code></pre></div>
<h3 id="csv-parser"><span class="header-section-number">3.3.2</span> CSV Parser</h3>
<p>Parsing Combinators can be used to write powerful, modular, readable, and concise parsers for any format of text. For example, here is a CSV parser in 5 lines of code.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">expression <span class="op">=</span> Parser.noneof(<span class="st">&#39;,</span><span class="ch">\n</span><span class="st">&#39;</span>).many1()
comma <span class="op">=</span> Parser.char(<span class="st">&#39;,&#39;</span>)
newline <span class="op">=</span> Parser.char(<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)
line <span class="op">=</span> (expression <span class="op">&lt;=</span> comma.optional()).many_list()
csv <span class="op">=</span> (line <span class="op">&lt;=</span> newline.optional()).many_list()

<span class="co"># Example</span>
text <span class="op">=</span> <span class="st">&#39;&#39;&#39;1,2,3,4,5</span>
<span class="st">hello world, my, good, friends, 5</span>
<span class="st">0,1,2,3,4&#39;&#39;&#39;</span>

<span class="bu">print</span>(csv.parse_total(text))
<span class="co"># Ok(</span>
<span class="co">#     [</span>
<span class="co">#         [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;],</span>
<span class="co">#         [&#39;hello world&#39;, &#39; my&#39;, &#39; good&#39;, &#39; friends&#39;, &#39; 5&#39;],</span>
<span class="co">#         [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</span>
<span class="co">#     ]</span>
<span class="co"># )</span></code></pre></div>
<h3 id="abstract-syntax-tree-parser"><span class="header-section-number">3.3.3</span> Abstract Syntax Tree Parser</h3>
<p>And finally, here is a full arithmetic expression parser. This is more powerful than the power of regular expressions to break a string into tokens. It constructs the full AST from a purely textual input, just using a Parser Combinator. You'll notice that at this point, I need to define a function and pass that in to a Parser; we need to do this because this is a recursive expression we are parsing. However, it doesn't actually add to the complexity too much.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> collections <span class="im">import</span> namedtuple
<span class="im">from</span> enum <span class="im">import</span> Enum, auto

<span class="kw">class</span> Op(Enum):
    PLUS <span class="op">=</span> auto()
    MINUS <span class="op">=</span> auto()
    TIMES <span class="op">=</span> auto()
    DIV <span class="op">=</span> auto()

Expr <span class="op">=</span> namedtuple(<span class="st">&#39;Expr&#39;</span>, [<span class="st">&#39;Op&#39;</span>,<span class="st">&#39;e1&#39;</span>,<span class="st">&#39;e2&#39;</span>])

openp <span class="op">=</span> Parser.char(<span class="st">&#39;(&#39;</span>) <span class="op">+</span> whitespace.optional()
closep <span class="op">=</span> whitespace.optional() <span class="op">+</span> Parser.char(<span class="st">&#39;)&#39;</span>)
plus <span class="op">=</span> whitespace.optional() <span class="op">+</span> Parser.char(<span class="st">&#39;+&#39;</span>)
        <span class="op">+</span> whitespace.optional()
minus <span class="op">=</span> whitespace.optional() <span class="op">+</span> Parser.char(<span class="st">&#39;-&#39;</span>)
        <span class="op">+</span> whitespace.optional()
times <span class="op">=</span> whitespace.optional() <span class="op">+</span> Parser.char(<span class="st">&#39;*&#39;</span>)
        <span class="op">+</span> whitespace.optional()
div <span class="op">=</span> whitespace.optional() <span class="op">+</span> Parser.char(<span class="st">&#39;/&#39;</span>)
        <span class="op">+</span> whitespace.optional()

Plus <span class="op">=</span> <span class="kw">lambda</span> x: Expr(Op.PLUS, x[<span class="dv">0</span>], x[<span class="dv">1</span>])
Minus <span class="op">=</span> <span class="kw">lambda</span> x: Expr(Op.MINUS, x[<span class="dv">0</span>], x[<span class="dv">1</span>])
Times <span class="op">=</span> <span class="kw">lambda</span> x: Expr(Op.TIMES, x[<span class="dv">0</span>], x[<span class="dv">1</span>])
Div <span class="op">=</span> <span class="kw">lambda</span> x: Expr(Op.DIV, x[<span class="dv">0</span>], x[<span class="dv">1</span>])

<span class="kw">def</span> expr(text):
    <span class="co"># rec stands for recursive</span>
    rec_plus <span class="op">=</span> ((openp <span class="op">&gt;=</span> Parser(expr))
                <span class="op">&amp;</span> (plus <span class="op">&gt;=</span> Parser(expr))) <span class="op">&lt;=</span> closep
    rec_minus <span class="op">=</span> ((openp <span class="op">&gt;=</span> Parser(expr))
                <span class="op">&amp;</span> (minus <span class="op">&gt;=</span> Parser(expr))) <span class="op">&lt;=</span> closep
    rec_times <span class="op">=</span> ((openp <span class="op">&gt;=</span> Parser(expr))
                <span class="op">&amp;</span> (times <span class="op">&gt;=</span> Parser(expr))) <span class="op">&lt;=</span> closep
    rec_div <span class="op">=</span> ((openp <span class="op">&gt;=</span> Parser(expr))
                <span class="op">&amp;</span> (div <span class="op">&gt;=</span> Parser(expr))) <span class="op">&lt;=</span> closep
    
    full <span class="op">=</span> (
                (rec_plus <span class="op">&gt;</span> Plus)
                <span class="op">|</span> (rec_minus <span class="op">&gt;</span> Minus)
                <span class="op">|</span> (rec_times <span class="op">&gt;</span> Times)
                <span class="op">|</span> (rec_div <span class="op">&gt;</span> Div)
                <span class="op">|</span> number
           )

    <span class="cf">return</span> full(text)

text <span class="op">=</span> <span class="st">&#39;((1+2) * (9 - 11))&#39;</span>

<span class="bu">print</span>(Parser(expr).parse_total(text))
<span class="co"># Ok(</span>
<span class="co">#     Expr(</span>
<span class="co">#         Op=&lt;Op.TIMES: 3&gt;,</span>
<span class="co">#         e1=Expr(</span>
<span class="co">#             Op=&lt;Op.PLUS: 1&gt;,</span>
<span class="co">#             e1=1.0,</span>
<span class="co">#             e2=2.0</span>
<span class="co">#         ),</span>
<span class="co">#         e2=Expr(</span>
<span class="co">#             Op=&lt;Op.MINUS: 2&gt;,</span>
<span class="co">#             e1=9.0,</span>
<span class="co">#             e2=11.0</span>
<span class="co">#         )</span>
<span class="co">#     )</span>
<span class="co"># )</span></code></pre></div>
<p>I decided to reproduce this sort of code using standard regular expressions; Not only did that version have twice as many lines, it was a much more fragile program. I didn't thoroughly test it, but its behavior when given wrong input wasn't well defined, and there were edge cases that might result in malformed results. The Parsing Combinator above, however, is short and will always return an Error Result with a sensible error message if an error happens.</p>
<h1 id="theory-of-monads"><span class="header-section-number">4</span> Theory of Monads</h1>
<p>Now that we've seen a few examples of what a Monad is, we can talk about the formal definition. This is going to be the most abstract section of the text, but I'll try and keep any statements from category theory or abstract algebra from appearing here.</p>
<h2 id="defining-monads"><span class="header-section-number">4.1</span> Defining Monads</h2>
<p>Monads are a special type of object that contains with in it a value and a context. Our Option and Result Monads contained the result of a computation, along with contextual information regarding whether the operation had succeeded or failed. This allowed us to write programs that could detect failure elegantly. Our Parsing Monad contained the result of the parsing so far, as well as the rest of the text remaining to be parsed. Whenever you see a Monad, you can sum up its operation by asking &quot;What is the value in this Monad, and what is the context?&quot;. Many people, when confronted with Monads, want a way to get the value out of the Monad. But this causes problems, because you've taken the value out of context, and it becomes significantly more useless.</p>
<p>In order to interact with the values without taking them out of their context, we have a function called <code>fmap</code>. <code>fmap</code> takes the value, and applies the function to that value, and puts the result of he function back into context. In our Option and Result Monads, it applied the function to the value if our computation was successful, or it simply bypassed the function if our computation had failed. In our parsing combinator, it applied the function to the result of our computation, while leaving the remainder of the text to be parsed alone.</p>
<p>However, this meant that we couldn't use functions on the values in our Monad if the functions themselves returned Monads. For our Option and Result Monads, that means that we couldn't use a function that could fail (a function that returned an Option or Result Monad) on our Monad with <code>fmap</code>. If we did that, we could end up with a recursive Monad, like <code>Some(None)</code> or <code>Some(Some(3))</code>. This is annoying, and there's two ways to fix this weirdness.</p>
<p>The first way, which we used in the previous section, is to use a function called <code>bind</code>. <code>bind</code> is the same as <code>fmap</code>, but instead of putting the return value of the function passed to <code>bind</code> back into the same context, it expects that <code>bind</code> will return a new value and context (a Monad of some kind).</p>
<p>The second way is an alternative to <code>bind</code>; you don't need both, and it's more common to have <code>bind</code> as the one to use, so I haven't bothered talking about it yet. This function is called <code>join</code>, and it takes a recursive Monad and flattens it from two layers to one layer. For example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Option.some(Option.some(x)).join() <span class="op">==</span> Option.some(x)
Option.some(Option.none()).join() <span class="op">==</span> Option.none()
Option.none().join() <span class="op">==</span> Option.none()</code></pre></div>
<p>We can show that <code>join</code> isn't any less useful than <code>bind</code> by actually writing <code>bind</code> using only <code>join</code> and <code>fmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> bind(monad, function):
    <span class="cf">return</span> monad.fmap(function).join()</code></pre></div>
<p>This does the same thing as <code>bind</code> usually does; it applies the function to the inside value if the Monad isn't Nothing, and then it returns Nothing if either the function returns or the Monad is Nothing, or it returns Some(value) if the function succeeds and the Monad had a value to pass into the function.</p>
<p>We can also show a way to write <code>fmap</code> and <code>join</code> solely using <code>bind</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> fmap(monad, function):
    monad.bind(<span class="kw">lambda</span> x: Option.some(function(x)))

<span class="kw">def</span> join(monad):
    monad.bind(<span class="kw">lambda</span> x: x.unwrap() <span class="cf">if</span> x.is_some() <span class="cf">else</span> x)</code></pre></div>
<p>This means, for our purposes, for something to be a Monad, we require it to either have both <code>fmap</code> <em>and</em> <code>join</code>, or <code>bind</code>.</p>
<h2 id="monad-laws"><span class="header-section-number">4.2</span> Monad Laws</h2>
<p>Now, Monads have three laws, or rules, they have to follow; this is just to make sure Monads don't have any unexpected behavior, but we should go over those rules anyway.</p>
<p>First of all, if you <code>fmap</code> over a Monad with the identity function (a function that returns its inputs unchanged), the value in the Monad doesn't change.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Monad(x).fmap(<span class="kw">lambda</span> x: x) <span class="op">==</span> Monad(x)</code></pre></div>
<p>Secondly, if you <code>fmap</code> two functions in a row, it should be the same as simply <code>fmap</code>ing the function which does the equivalent of those two functions in order.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.fmap(<span class="kw">lambda</span> x: x<span class="dv">+1</span>).fmap(<span class="kw">lambda</span> x: x<span class="dv">+2</span>) <span class="op">==</span> m.fmap(<span class="kw">lambda</span> x: x<span class="dv">+3</span>)</code></pre></div>
<p>Finally, if you apply a function to a value and then stick it in a Monad, it is the same as putting that value in a Monad and <code>fmap</code>ing that function.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Monad(x).fmap(f) <span class="op">==</span> Monad(f(x))</code></pre></div>
<p>If you want, you can put these rules into equivalent forms using <code>bind</code> instead of <code>fmap</code>.</p>
<p>These might seem common sense, and if they are, that's good! The only reason that we require that these rules are followed is so that somebody doesn't create a Monad that behaves weirdly and it screws up our program. If they don't seem common sense, that's okay; you don't really have to understand them.They basically boil down to &quot;Monads should behave sensibly when you fmap functions over them&quot;.</p>
<h1 id="the-zeroth-monad"><span class="header-section-number">5</span> The Zeroth Monad</h1>
<p>Our first section was titled 'Our First Monad'. However, we are computer scientists, and therefore we start counting at zero, not at one. So let's talk about another Monad that everyone reading this document has probably used, but never noticed that it was a Monad. It turns out that a list is a Monad.</p>
<p>How is a list a Monad? Well, from the previous section, a Monad is really just anything with a <code>bind</code> function, or with a <code>fmap</code> and a <code>join</code> function. And while not every programming language has these functions built in, we can easily write these functions for a list.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># python has a built in function, &#39;map&#39; that does this.</span>
<span class="kw">def</span> fmap(ls, function):
    new <span class="op">=</span> []
    <span class="cf">for</span> item <span class="op">in</span> ls:
        new.append(function(item))
    <span class="cf">return</span> new

<span class="co"># this is sometimes called &#39;flatten&#39;</span>
<span class="kw">def</span> join(ls):
    new <span class="op">=</span> []
    <span class="cf">for</span> sublist <span class="op">in</span> ls:
        <span class="cf">for</span> item <span class="op">in</span> sublist:
            new.append(item)
    <span class="cf">return</span> new

<span class="co"># bind can be defined entirely with the other two!</span>
<span class="kw">def</span> bind(ls, function):
    <span class="cf">return</span> join(fmap(ls, function))</code></pre></div>
<p>This is all nice and well that we now have these functions, but it explains little conceptually. So let's try and describe Monads conceptually, and see how that can be applied to lists.</p>
<p>Our first Monads, the Option Monad and the Result Monad, both represented some sort of computation result that required more context than a simple value; in particular, they represented a computation result that could either succeed, producing a value, or fail, producing no meaningful value.</p>
<p>Lists can be thought of in a similar way; instead of representing either zero or one meaningful return value, lists can represent computations that can return zero, one, or any possible number of return values. For example, consider the following contrived example.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> less_than_abs(x):
    <span class="cf">if</span> x <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> []
    ls <span class="op">=</span> [<span class="dv">0</span>]
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>,x):
        ls.append(i)
        ls.append(<span class="op">-</span>i)
    <span class="cf">return</span> ls

<span class="im">from</span> math <span class="im">import</span> sqrt

<span class="kw">def</span> sqrts(x):
    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span>:
        <span class="cf">return</span> []
    <span class="cf">elif</span> x <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> [<span class="fl">0.0</span>]
    <span class="cf">else</span>:
        <span class="cf">return</span> [sqrt(x), <span class="op">-</span>sqrt(x)]

bind(
    bind(
        [<span class="dv">3</span>],
        less_than_abs
    ),
    sqrts
)
<span class="co"># [0.0, 1.0, -1.0, 1.4142135623730951, -1.4142135623730951]</span></code></pre></div>
<p>In this case, we execute two functions in series, getting all of the valid results to our question in one list; but the number of results isn't the same for all inputs, so we need a Monad to represent this computational uncertainty.</p>

<p></p>
<h1 id="code-the-result-monad"><span class="header-section-number">6</span> Code: The Result Monad</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Result:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value, message):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._message <span class="op">=</span> message
        <span class="va">self</span>._value <span class="op">=</span> value

    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Option.error({})&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(<span class="va">self</span>._message))
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Option.ok({})&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(<span class="va">self</span>._value))

    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Error({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._message)
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Ok({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._value)

    <span class="kw">def</span> is_ok(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="va">False</span>
        <span class="cf">return</span> <span class="va">True</span>

    <span class="kw">def</span> is_error(<span class="va">self</span>):
        <span class="cf">return</span> <span class="op">not</span> <span class="va">self</span>.is_ok()
    
    <span class="kw">def</span> unwrap(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.is_ok():
            <span class="cf">return</span> <span class="va">self</span>._value
        <span class="cf">else</span>:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Result is an Error&#39;</span>)
    
    <span class="kw">def</span> error_msg(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>._message
        <span class="cf">else</span>:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Result is Ok&#39;</span>)
            
    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="cf">return</span> function(val)
        
    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="cf">return</span> Result.ok(function(val))
    
    <span class="kw">def</span> recover(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> function()
        
        <span class="cf">return</span> <span class="va">self</span>
    
    <span class="kw">def</span> <span class="fu">__rshift__</span>(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bind(function)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> ok(cls, val):
        <span class="cf">return</span> cls(<span class="va">False</span>, val, <span class="va">None</span>)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> error(cls, msg):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>, msg)

<span class="co"># The following are built in functions</span>
<span class="co"># rewritten to work with the Result Monad</span>

<span class="kw">def</span> result_open(filename, mode<span class="op">=</span><span class="st">&#39;r&#39;</span>):
    <span class="cf">try</span>:
        fd <span class="op">=</span> Result.ok(<span class="bu">open</span>(filename, mode<span class="op">=</span>mode))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        fd <span class="op">=</span> Result.error(<span class="st">&quot;Failed to open the file&quot;</span>)
    <span class="cf">return</span> fd

<span class="kw">def</span> result_read(fd, size<span class="op">=-</span><span class="dv">1</span>):
    <span class="cf">try</span>:
        data <span class="op">=</span> Result.ok(fd.read(size))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        data <span class="op">=</span> Result.error(<span class="st">&quot;Failed to read from the file&quot;</span>)
    <span class="cf">return</span> data

<span class="im">import</span> re

<span class="kw">def</span> result_match(pattern, string):
    match <span class="op">=</span> re.match(pattern, string)
    <span class="cf">if</span> match:
        match <span class="op">=</span> Result.ok(match)
    <span class="cf">else</span>:
        match <span class="op">=</span> Result.error(<span class="st">&quot;Failed to match the pattern&quot;</span>)
    <span class="cf">return</span> match

<span class="kw">def</span> result_get_group(match, group):
    <span class="cf">try</span>:
        g <span class="op">=</span> match.group(group)
    <span class="cf">except</span> <span class="pp">Exception</span>:
        g <span class="op">=</span> <span class="va">None</span>

    <span class="cf">if</span> g <span class="op">==</span> <span class="va">None</span>:
        g <span class="op">=</span> Result.error(<span class="st">&quot;Failed to get the group from the match&quot;</span>)
    <span class="cf">else</span>:
        g <span class="op">=</span> Result.ok(g)
        
    <span class="cf">return</span> g

<span class="kw">def</span> result_int(s):
    <span class="cf">try</span>:
        i <span class="op">=</span> Result.ok(<span class="bu">int</span>(s))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        i <span class="op">=</span> Result.error(<span class="st">&quot;Failed to parse into an integer&quot;</span>)
    <span class="cf">return</span> i


result <span class="op">=</span> (
    Result.ok(<span class="st">&#39;text.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> result_open
      <span class="op">&gt;&gt;</span> result_read
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: result_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: result_get_group(x, <span class="dv">1</span>))
      <span class="op">&gt;&gt;</span> result_int
    )

<span class="bu">print</span>(result)</code></pre></div>
<h1 id="code-the-parsing-combinator"><span class="header-section-number">7</span> Code: The Parsing Combinator</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Parser:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, function):
        <span class="va">self</span>._function <span class="op">=</span> function
        
    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, text):
        x <span class="op">=</span> <span class="va">self</span>._function(text)
        <span class="cf">return</span> x

    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">&#39;&lt;Parsing Combinator&gt;&#39;</span>
            
    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        
        <span class="kw">def</span> bind_func(result):
            <span class="cf">return</span> function(result[<span class="dv">0</span>]).bind(<span class="kw">lambda</span> x: Result.ok((x, result[<span class="dv">1</span>])))

        <span class="cf">return</span> Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text).bind(bind_func))
    
    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bind(<span class="kw">lambda</span> x: Result.ok(function(x)))
    
    <span class="kw">def</span> combine(<span class="va">self</span>, other, function):
        
        <span class="kw">def</span> combine_func(match, rest):
            res <span class="op">=</span> other(rest)
            <span class="cf">if</span> res.is_ok():
                other_match, rest <span class="op">=</span> res.unwrap()
                new_match <span class="op">=</span> function(match, other_match)
                <span class="cf">return</span> Result.ok((new_match, rest))
            <span class="cf">else</span>:
                <span class="cf">return</span> res
            
        <span class="cf">return</span> Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text).bind(<span class="kw">lambda</span> res: combine_func(<span class="op">*</span>res)))
    
    <span class="kw">def</span> concat(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x, y: x <span class="op">+</span> y)
    
    <span class="kw">def</span> choice(<span class="va">self</span>,other):
        
        <span class="kw">def</span> choice_func(text):
            <span class="cf">return</span> <span class="va">self</span>(text).recover(<span class="kw">lambda</span>: other(text))
        
        <span class="cf">return</span> Parser(choice_func)
    
    <span class="kw">def</span> many(<span class="va">self</span>, function<span class="op">=</span><span class="kw">lambda</span> x,y: x <span class="op">+</span> y):
        
        <span class="kw">def</span> repeat_func(text):
            res <span class="op">=</span> <span class="va">self</span>(text)
            
            <span class="cf">if</span> res.is_error():
                <span class="cf">return</span> Result.ok((<span class="st">&#39;&#39;</span>,text))
            
            match <span class="op">=</span> res.unwrap()[<span class="dv">0</span>]
            rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
            
            res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">while</span> res.is_ok():
                match <span class="op">=</span> function(match, res.unwrap()[<span class="dv">0</span>])
                rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
                res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">return</span> Result.ok((match, rest))
            
        <span class="cf">return</span> Parser(repeat_func)
    
    <span class="kw">def</span> many_list(<span class="va">self</span>):
        
        <span class="kw">def</span> repeat_func(text):
            res <span class="op">=</span> <span class="va">self</span>(text)
            
            <span class="cf">if</span> res.is_error():
                <span class="cf">return</span> Result.ok((<span class="st">&#39;&#39;</span>,text))
            
            match <span class="op">=</span> [res.unwrap()[<span class="dv">0</span>]]
            rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
            
            res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">while</span> res.is_ok():
                match <span class="op">=</span> match <span class="op">+</span> [res.unwrap()[<span class="dv">0</span>]]
                rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
                res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">return</span> Result.ok((match, rest))
            
        <span class="cf">return</span> Parser(repeat_func)
        
    <span class="kw">def</span> many1(<span class="va">self</span>, function<span class="op">=</span><span class="kw">lambda</span> x,y: x <span class="op">+</span> y):
        <span class="cf">return</span> <span class="va">self</span>.combine(<span class="va">self</span>.many(function), function)
    
    <span class="kw">def</span> many1_list(<span class="va">self</span>):
        <span class="cf">return</span> <span class="va">self</span>.combine(<span class="va">self</span>.many_list(function), function)
    
    <span class="kw">def</span> optional(<span class="va">self</span>):
        <span class="cf">return</span> <span class="va">self</span> <span class="op">|</span> Parser.empty()
    
    <span class="kw">def</span> first(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: x)
    
    <span class="kw">def</span> last(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: y)
    
    <span class="kw">def</span> <span class="bu">tuple</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: (x,y))

    <span class="kw">def</span> <span class="fu">__rshift__</span>(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bind(function)
    
    <span class="kw">def</span> <span class="fu">__gt__</span>(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.fmap(function)
    
    <span class="kw">def</span> <span class="fu">__ge__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.last(other)
    
    <span class="kw">def</span> <span class="fu">__le__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.first(other)
        
    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.concat(other)
        
    <span class="kw">def</span> <span class="fu">__or__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.choice(other)

    <span class="kw">def</span> <span class="fu">__and__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">tuple</span>(other)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> char(cls, val):

        <span class="kw">def</span> match_char(text):
            <span class="cf">try</span>:
                current <span class="op">=</span> text[<span class="dv">0</span>]
            <span class="cf">except</span> <span class="pp">IndexError</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but &#39;</span> <span class="op">+</span>
                    <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(val)))
            
            <span class="cf">if</span> current <span class="op">==</span> val:
                <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to match character {} at {}&#39;</span>
                    .<span class="bu">format</span>(<span class="bu">repr</span>(val), <span class="bu">repr</span>(text)))

        <span class="cf">return</span> Parser(match_char)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> empty(cls):

        <span class="kw">def</span> match_empty(text):
            <span class="cf">return</span> Result.ok((<span class="st">&#39;&#39;</span>, text))

        <span class="cf">return</span> Parser(match_empty)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> oneof(cls, charls):

        <span class="kw">def</span> match_charls(text):
            <span class="cf">try</span>:
                current <span class="op">=</span> text[<span class="dv">0</span>]
            <span class="cf">except</span> <span class="pp">IndexError</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but one of &#39;</span> <span class="op">+</span>
                <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">list</span>(charls)))

            <span class="cf">if</span> current <span class="op">in</span> charls:
                <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to match one of {} at {}&#39;</span>
                    .<span class="bu">format</span>(<span class="bu">list</span>(charls), <span class="bu">repr</span>(text)))

        <span class="cf">return</span> Parser(match_charls)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> noneof(cls, charls):

        <span class="kw">def</span> none_charls(text):
            <span class="cf">try</span>:
                current <span class="op">=</span> text[<span class="dv">0</span>]
            <span class="cf">except</span> <span class="pp">IndexError</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but none of &#39;</span> <span class="op">+</span>
                <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(text)))

            <span class="cf">if</span> current <span class="op">not</span> <span class="op">in</span> charls:
                <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;Found one of {} at {} &#39;</span>
                    <span class="op">+</span><span class="st">&#39;when there should be none of&#39;</span>.<span class="bu">format</span>(<span class="bu">list</span>(charls), <span class="bu">repr</span>(text)))

        <span class="cf">return</span> Parser(none_charls)

    <span class="kw">def</span> parse_prefix(<span class="va">self</span>, string):
        <span class="cf">return</span> <span class="va">self</span>(string)

    <span class="kw">def</span> parse_total(<span class="va">self</span>, string):
        
        <span class="kw">def</span> check_full(tup):
            <span class="cf">if</span> tup[<span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;&#39;</span>:
                <span class="cf">return</span> Result.ok(tup[<span class="dv">0</span>])
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;The match did not consist of the entire &#39;</span> <span class="op">+</span>
                    <span class="co">&#39;string: {} was left over&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(tup[<span class="dv">1</span>])))
            
        <span class="cf">return</span> <span class="va">self</span>(string) <span class="op">&gt;&gt;</span> check_full</code></pre></div>
