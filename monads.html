<h1 id="what-are-monads"><span class="header-section-number">1</span> What are Monads?</h1>
<p>It is entirely reasonable that this is the first question that anyone learning Monads asks, and it is also entirely reasonable that anyone who is teaching Monads answers. However, Monads are a complex concept that cannot be explained in a single sentence or even a single paragraph; to understand Monads you must simultaneously understand the problem they are trying to solve, their implementation, the interface for working with them, and the theoretical computational background. Therefore, I will not try to answer this question in a single phrase; my explanation of what Monads are is the entirety of this paper.</p>
<p>I would like to take a few moments to clear up one possible misconception. Monads are not special. They are a data structure, just like a Linked List or a Dictionary. They have methods that you can call, and they store data in the same way. They do not have a common sounding name, so they seem scary, and people have a tendency to define them using complex math or weird analogies, but I firmly believe that Monads are not actually any more complicated than the run of the mill data structures that programmers use every day.</p>
<h2 id="bad-explanations"><span class="header-section-number">1.1</span> Bad Explanations</h2>
<p>Of all the one liner explanations of Monads, two stand out as being slightly useful.</p>
<ul>
<li>Monads are Containers (We will see the truth of this in Section 2)</li>
<li>Monads are Computations (We will see the truth of this in Section 3)</li>
</ul>
<p>Those sentences, while true, are useless to the first time user of Monads, because they have no experience with actual Monads. Hopefully, by the end of this paper, the reader will be able to understand these analogies.</p>
<p>In contrast, several other explanations range from useless to wrong.</p>
<ul>
<li>Monads are monoids in the category of endofunctors</li>
<li>Monads are the the totality of all beings</li>
</ul>
<p>The first definition is correct, and if you already know what a monoid, a category, and an endofunctor is, congratulations! You probably are working on, or have, your PhD, and you can use that definition to help inform the rest of this essay. If you have no idea what those words mean, don't worry about trying to interpret them. They're mathy words to describe what we're going to talk about later in more plain terms.</p>
<p>The second definition is wrong. It refers to a completely different concept in philosophy and theology that happens to have the same name. Ignore it.</p>
<p>Finally, we have definitions that are absurd:</p>
<ul>
<li>Monads are like burritos</li>
</ul>
<p>I have seen people make fun of this definition a lot, but I've never seen it actually used. However, I doubt that it will be useful to anyone who doesn't know what Monads are.</p>
<p>Finally, I want to remark upon how varied and different Monads truly are; This essay intends to introduce a few common monads, and provide a framework for thinking about them, but you will still come across Monads which are foreign to you. By an analogy; consider this paper an introduction to music, where I talk about classical music, jazz, and rock and roll. That barely covers many genres of music; a reader of that paper would be confounded upon hearing rap for the first time.</p>
<h1 id="our-first-monads"><span class="header-section-number">2</span> Our First Monads</h1>
<p>In this section, we will explore the common problem of how to report errors to the caller of a function, and provide a solution to the problem using one of the simplest Monads.</p>
<h2 id="error-handling-in-plain-python"><span class="header-section-number">2.1</span> Error Handling in Plain Python</h2>
<p>Python usually uses Exception raising and catching to report errors that happen during execution. It is a desirable feature to have in a scripting language, but it is less useful in systems languages like C, Go, or Rust, because exceptions are expensive in terms of memory and CPU time. It's also less useful in functional languages like Haskell or Scala, which use types and abstract data structures to make code more predictable and safer, a goal which is undermined when code can throw exceptions that crash the whole program. In the following section, I'll be exploring ways to handle errors in Python without throwing exceptions and without using Monads.</p>
<h3 id="division"><span class="header-section-number">2.1.1</span> Division</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> division(x, y):
    <span class="cf">return</span> x <span class="op">/</span> y</code></pre></div>
<p>Consider the above code fragment. This is a very simple function; one that is so simple it hardly deserves to exist. However, if <code>y</code> is zero, this function can throw a <code>ZeroDevisionError</code>. It's possible that we want to recover from this error gracefully: check the inputs and see if an error will occur, and return some error code instead of raising an exception.</p>
<p>However, we must decide what the error code should be. We cannot choose <code>0.0</code>, because that is correctly returned by <code>division(0.0,1.0)</code>. We cannot choose <code>-1.0</code>, because that is correctly returned by <code>division(-1.0,1.0)</code>. In fact, this function can return any possible floating point number, so we can't choose a floating point number as our error code. One solution is to return a float on success, but <code>None</code> on failure.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> division(x, y):
    <span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> <span class="va">None</span>
    <span class="cf">return</span> x <span class="op">/</span> y</code></pre></div>
<p>Now we have written a function that checks whether or not division is possible, and performs division if it is, but returns an error code if it is not.</p>
<h3 id="indexing"><span class="header-section-number">2.1.2</span> Indexing</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> index(ls, i):
    <span class="cf">return</span> ls[i]</code></pre></div>
<p>The above code is similar to the last example; it will perform an index lookup into a list and return the item from the list if it can. If it cannot, we are still left with the problem: it throws an exception if the index is out of bounds. Let's try to do the same thing as above; rewrite this function so that it does not throw an error but instead uses an error code to signal something has gone wrong.</p>
<p>Our first guess might be to have our error code be the same as above, and just return <code>None</code>. However, this causes false positives, because the code <code>index([None], 0)</code> would also return <code>None</code>. In fact, python lets any value be inside of a list; there is no possible error code we can return that cannot also be in the list. Luckily, python lets us use multiple return values.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> <span class="va">False</span>, <span class="va">None</span>
    <span class="cf">return</span> <span class="va">True</span>, ls[i]</code></pre></div>
<p>This allows us to actually check whether or not this function has failed, without worrying about receiving an exception. This allows us to handle errors from outside of the function in a logical way:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">ok, value <span class="op">=</span> index([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],<span class="dv">0</span>)
<span class="cf">if</span> <span class="op">not</span> ok:
    <span class="bu">print</span>(<span class="st">&quot;Oh no, we failed&quot;</span>)
<span class="cf">else</span>:
    <span class="bu">print</span>(value)</code></pre></div>
<h3 id="combining-the-above"><span class="header-section-number">2.1.3</span> Combining The Above</h3>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> divide_elements(ls, i1, i2):
    <span class="cf">return</span> ls[i1]<span class="op">/</span>ls[i2]</code></pre></div>
<p>Now, we have combined the two operations in python which might lead to an exception, and we have done it in a way that allows for three different operations to result in an exception. We can rewrite this function so that it will not throw any errors by checking after each step for an error code.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> <span class="va">True</span>, <span class="va">None</span>
    <span class="cf">return</span> <span class="va">False</span>, ls[i]

<span class="kw">def</span> division(x, y):
    <span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> <span class="va">None</span>
    <span class="cf">return</span> x <span class="op">/</span> y

<span class="kw">def</span> divide_elements(ls, i1, i2):
    failure, v1 <span class="op">=</span> index(ls, i1)
    <span class="cf">if</span> failure:
        <span class="cf">return</span> <span class="va">None</span>
    
    failure, v2 <span class="op">=</span> index(ls, i2)
    <span class="cf">if</span> failure:
        <span class="cf">return</span> <span class="va">None</span>
    
    <span class="cf">return</span> division(v1, v2)</code></pre></div>
<p>This code works nicely; you can throw two types of errors at it, and it returns <code>None</code> when either occurs.</p>
<h3 id="other-programming-languages"><span class="header-section-number">2.1.4</span> Other Programming Languages</h3>
<p>Python has been very nice to us so far. In Python, it is easy to write a function that returns two values, or returns different types in different scenarios. Python also has other features, such as Exceptions, which make this rewriting we've been doing sort of useless. The most Pythonic way of writing the above would probably be to catch the exceptions:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> divide_elements(ls, i1, i2):
    <span class="cf">try</span>:
        <span class="cf">return</span> ls[i1]<span class="op">/</span>ls[i2]
    <span class="cf">except</span> (<span class="pp">IndexError</span>, <span class="pp">ZeroDivisionError</span>):
        <span class="cf">return</span> <span class="va">None</span></code></pre></div>
<p>Other languages have their own ways of dealing with the errors we discussed above, and they all have their own benefits. In C, the common pattern is to have the actual return value of the function be a number that indicates whether an error occurred, and if one did, what the error was. To get the meaningful result from the function, you pass a pointer to a block of memory into the function, and that function writes the answer you want into that block of memory. This is much faster and simpler than having to write all of the infrastructure required to deal with throwing exceptions and allowing someone above you to catch that exception.</p>
<p>In many modern languages, including Rust, Scala, and Haskell, the solution of choice is to use Monads.</p>
<h2 id="the-option-monad"><span class="header-section-number">2.2</span> The Option Monad</h2>
<p>The Option Monad, also called the Maybe Monad in many programming languages, is a way of representing the result of a function or computation that might result in an error and produce no meaningful output. We call an Option Monad that has a value and represents a successful computation Some, and we call one that does not have a value and represents a failed computation Nothing.</p>
<p>These Monads are really easy to write in programming languages like Haskell, Scala, or Rust, but I'm going to write an implementation of the Option Monad in Python to help avoid any confusion about its inner workings. In the end, all Monads are just objects, like trees, lists, or dictionaries.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Option:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._value <span class="op">=</span> value

    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Nothing&#39;</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Some({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._value)
            
    <span class="kw">def</span> is_some(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="va">False</span>
        <span class="cf">return</span> <span class="va">True</span>

    <span class="kw">def</span> is_none(<span class="va">self</span>):
        <span class="cf">return</span> <span class="op">not</span> <span class="va">self</span>.is_some()

    <span class="kw">def</span> unwrap(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Option has no value&#39;</span>)
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">self</span>._value
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> some(cls, x):
        <span class="cf">return</span> cls(<span class="va">False</span>, x)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> none(cls):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>)</code></pre></div>
<p>This is the longest piece of code we have had so far, so let me break it down bit by bit.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Option:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._value <span class="op">=</span> value
    
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Nothing&#39;</span>
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Some({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._value)</code></pre></div>
<p>The <code>__init__</code> function is the constructor or initializer function for classes in python. Here all we do is create a boolean that indicates whether or not we have failed the computation. If we have not failed it, we store the result of the computation in <code>_value</code>. Note that if <code>_failed</code> is <code>True</code>, then we don't care what is in <code>_value</code>, because the computation has failed and that value has no meaning. I will note that the users of this class will probably never call <code>__init__</code> themselves, as we will later write alternate constructors that are easier for people to use.</p>
<p>The <code>__repr__</code> function simply tells python how this object should be printed.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> is_some(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="va">False</span>
        <span class="cf">return</span> <span class="va">True</span>
        
    <span class="kw">def</span> is_none(<span class="va">self</span>):
        <span class="cf">return</span> <span class="op">not</span> <span class="va">self</span>.is_some()

    <span class="kw">def</span> unwrap(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Option has no value&#39;</span>)
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="va">self</span>._value</code></pre></div>
<p>These three functions are the meat of the Option Monad; these are the ways we interact with it. The <code>is_some</code> function returns <code>True</code> when there is a meaningful return value, and <code>False</code> if the computation failed. <code>is_none</code> does the opposite. <code>unwrap</code> returns the value of the Option Monad <em>if there is a value to be returned</em>, otherwise it throws an error. In order to use the <code>unwrap</code> function without an error, you must first check to see whether the computation succeeded or failed.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="at">@classmethod</span>
    <span class="kw">def</span> some(cls, x):
        <span class="cf">return</span> cls(<span class="va">False</span>, x)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> none(cls):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>)</code></pre></div>
<p>These functions, decorated with <code>@classmethod</code>, aren't methods of the object. Instead, they are methods that exist as part of the class itself; here, we use them as alternate constructors.</p>
<p>At this point, let me rewrite our exception-free code from above using the Option Monad.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> division(x, y):
    <span class="cf">if</span> y <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(x <span class="op">/</span> y)

<span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(ls[i])

<span class="kw">def</span> divide_elements(ls, i1, i2):
    res1 <span class="op">=</span> index(ls, i1)
    <span class="cf">if</span> res1.is_none():
        <span class="cf">return</span> Option.none()
    
    res2 <span class="op">=</span> index(ls, i2)
    <span class="cf">if</span> res2.is_none():
        <span class="cf">return</span> Option.none()
    
    <span class="cf">return</span> division(res1.unwrap(), res2.unwrap())</code></pre></div>
<p>The above code is the exact same length in lines; and already has some benefits. First, these functions have a return type that can be determined just be looking at the code, is more useful in statically typed languages than dynamically typed languages (like Python). Second, we do not have to remember the convention for every function. Before, we had to remember that <code>division</code> returned <code>None</code> for an error, but <code>index</code> returned <code>False, None</code> for an error. Despite these benefits, the code is still filled with checks for errors and clustered with temporary variables.</p>
<p>And that's because we haven't yet implemented the most important function for a Monad. This is the most important but also the most complicated part of the Option Monad, so I am going to give it its own section.</p>
<h2 id="the-bind-and-fmap-functions"><span class="header-section-number">2.3</span> The Bind and Fmap Functions</h2>
<p>Currently, to operate on a value inside of an Option Monad, we need to manually unwrap it first. Instead of having to do this every time, we can instead define a new method on our Option Monad to do this for us.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="co"># function operates on the value inside of our Option Monad</span>
    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_none():
            <span class="co"># self is an Option Monad</span>
            <span class="cf">return</span> <span class="va">self</span>

        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        newval <span class="op">=</span> function(val)
        <span class="co"># We create a new Monad here to surround the new value</span>
        <span class="cf">return</span> Option.some(newval)
    <span class="co"># fmap returns an Option Monad.</span></code></pre></div>
<p>The fmap function is a higher order function. That means it is a function that takes another function as an argument, and does something with that function. If you look in the end of the previous section, we repeated this piece of code two times:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    res <span class="op">=</span> index(ls, i1)
    <span class="cf">if</span> res.is_none():
        <span class="cf">return</span> Option.none()</code></pre></div>
<p>We were checking whether a function had successfully computed a value or whether an error had occurred. If the value existed, we later passed that value into a function. If the value did not exist, then we simply returned the indication of failure, an <code>Option.none()</code> object.</p>
<p>Looking at bind, we can see it performs a similar operation. <code>res.fmap(function)</code> checks whether or not <code>res</code> is a successfully computed value, in which case it passes that value into <code>function</code>, or if it is a failed computation, in which case it simply returns itself, passing the failed computation forward.</p>
<p>But then it wraps the return value of the function into an Option Monad. Why? Well, for starters, it's just consistent. We want to be able to predict that <code>fmap</code> will return an Option Monad, as opposed to having to check the type every time it is returned. Secondly, it enables us to chain the <code>fmap</code> operation multiple times.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Option.some(<span class="op">-</span><span class="dv">62</span>).fmap(<span class="bu">abs</span>).fmap(<span class="bu">chr</span>)
<span class="co"># Some(&#39;&lt;&#39;)</span></code></pre></div>
<p>The above code is an example of chaining <code>fmap</code>; we start with some option value, <code>Some(-62)</code>, and we <code>fmap</code> the <code>abs</code> function, which computes the absolute values, and the <code>chr</code> function, which turns a number into its corresponding character. In this case, <code>62</code> corresponds to <code>'&lt;'</code>.</p>
<p>At a higher level, <code>fmap</code> unwraps the value in our Monad, and passes that value through a function. However, <code>fmap</code> does not do so blindly. It takes care to maintain all of the Monad's internal context for the value. In this case, that context is simple; all <code>fmap</code> has to do is return early with Nothing if the Monad <code>fmap</code> is called on is Nothing, and wrap the result of the function back into an Option Monad otherwise.</p>
<p>However, we can't quite use this function to fix the problem we had earlier. Let's see what happens if we try to use <code>fmap</code> in that case:</p>
<h1 id="aaah-izaak-uses-root-below-but-division-above"><span class="header-section-number">3</span> AAAH IZAAK USES ROOT BELOW BUT DIVISION ABOVE</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> math

<span class="kw">def</span> root(x):
    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span>:
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(math.sqrt(x))

<span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(ls[i])

<span class="kw">def</span> root_element(ls, i):
    <span class="cf">return</span> index(ls, i).fmap(root)</code></pre></div>
<p>This looks a lot nicer, but it doesn't quite work. We no longer have to do any manual unwrapping, but if we run this, we get a weird result:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">root_element([<span class="dv">1</span>,<span class="dv">2</span>,<span class="dv">3</span>],<span class="dv">1</span>)
<span class="co"># Some(Some(1.4142135623730951))</span></code></pre></div>
<p>Instead of having what we want, which is <code>Some(1.4142135623730951)</code>, we have our value wrapped in an extra Monadic layer. This is because our <code>root</code> function returns a Monad, and <code>fmap</code> wraps the result of <code>root</code> in a Monad. This is an annoying problem, and we can write a function to flatten it if we want, but instead, we usually write another function; <code>bind</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="co"># function returns an Option Monad</span>
    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_none():
            <span class="co"># self is an Option Monad</span>
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="co"># function returns an Option Monad</span>
        <span class="cf">return</span> function(val)
    <span class="co"># bind returns an Option Monad.</span></code></pre></div>
<p><code>bind</code> does essentially the same thing as <code>fmap</code>, but we expect that the function we pass to <code>bind</code> to be a monadic function; it needs to return a Monad. If we do this, we can use <code>bind</code> and <code>fmap</code> to chain function application on an Option Monad, and we can rewrite our above code again.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">import</span> math

<span class="kw">def</span> root(x):
    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span>:
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(math.sqrt(x))

<span class="kw">def</span> index(ls, i):
    <span class="cf">if</span> i <span class="op">&lt;</span> <span class="dv">0</span> <span class="op">or</span> i <span class="op">&gt;=</span> <span class="bu">len</span>(ls):
        <span class="cf">return</span> Option.none()
    <span class="cf">return</span> Option.some(ls[i])

<span class="kw">def</span> root_element(ls, i):
    <span class="cf">return</span> index(ls, i).bind(root)</code></pre></div>
<p>Now, we finally have a worthy example of how to use Option Monads. We have written two functions which use Option Monads to handle errors, and when we want to write a new function that uses both of those functions, we can completely ignore checking for errors or unwrapping values; we just use <code>bind</code> and let the Option Monad handle everything.</p>
<p>You may still think this sort of thing is useless; and in python, for such a simple example, it kinda is! But as we continue to explore Monads, we will encounter some examples that get more and more complex without Monads, but that Monads make simpler. Oh hey look, that's the next section.</p>
<h2 id="a-more-complex-example"><span class="header-section-number">3.1</span> A More Complex Example</h2>
<p>In order to give a more illustrative example of where the Option Monad can be more useful, consider the following problem; open a file, and read the first whitespace-terminated word from the beginning of the file, and parse it into an integer if possible. This problem is fairly easy to do with built-in Python functions, but the Option Monad can make error handling easier. However, none of Python's built-in functions use the Option Monad, so we will have to rewrite them so that they do. In languages with the Option Monad as a star player, such as Rust, Haskell, or Scala, this is not an issue.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> option_open(filename, mode<span class="op">=</span><span class="st">&#39;r&#39;</span>):
    <span class="cf">try</span>:
        fd <span class="op">=</span> Option.some(<span class="bu">open</span>(filename, mode<span class="op">=</span>mode))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        fd <span class="op">=</span> Option.none()
    <span class="cf">return</span> fd

<span class="kw">def</span> option_read(fd):
    <span class="cf">try</span>:
        data <span class="op">=</span> Option.some(fd.read())
    <span class="cf">except</span> <span class="pp">Exception</span>:
        data <span class="op">=</span> Option.none()
    <span class="cf">return</span> data

<span class="im">import</span> re

<span class="kw">def</span> option_match(pattern, string):
    match <span class="op">=</span> re.match(pattern, string)
    <span class="cf">if</span> match:
        match <span class="op">=</span> Option.some(match)
    <span class="cf">else</span>:
        match <span class="op">=</span> Option.none()
    <span class="cf">return</span> match

<span class="kw">def</span> option_get_group(match, group):
    <span class="cf">try</span>:
        g <span class="op">=</span> match.group(group)
    <span class="cf">except</span> <span class="pp">Exception</span>:
        g <span class="op">=</span> <span class="va">None</span>

    <span class="cf">if</span> g <span class="op">==</span> <span class="va">None</span>:
        g <span class="op">=</span> Option.none()
    <span class="cf">else</span>:
        g <span class="op">=</span> Option.some(g)
    
    <span class="cf">return</span> g

<span class="kw">def</span> option_int(s):
    <span class="cf">try</span>:
        i <span class="op">=</span> Option.some(<span class="bu">int</span>(s))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        i <span class="op">=</span> Option.none()

    <span class="cf">return</span> i</code></pre></div>
<p>These functions perform the exact same operations as their Python counterparts, but they return Some if the computation succeeds and Nothing if it fails, instead of throwing an error or using some other return code. This will allow us to use <code>bind</code> to chain these functions together.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">result <span class="op">=</span> (
    <span class="co"># We create a new Option Monad holding the string &#39;text.txt&#39;</span>
    Option.some(<span class="st">&#39;text.txt&#39;</span>)
    <span class="co"># We then bind our file opening function.</span>
    <span class="co"># The value returned from this function is</span>
    <span class="co"># an Option Monad holding a file object (or Nothing)</span>
    .bind(option_open)
    <span class="co"># We then bind our file reading function</span>
    <span class="co"># the value returned from this function is an</span>
    <span class="co"># Option Monad holding the contents of the file (or Nothing)</span>
    .bind(option_read)
    <span class="co"># We then bind a lambda to match the first word in the file.</span>
    <span class="co"># the value returned from this function is an</span>
    <span class="co"># Option Monad holding a regex match object (or Nothing)</span>
    .bind(<span class="kw">lambda</span> x: option_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
    <span class="co"># We then bind a lambda to get the string from the match object.</span>
    <span class="co"># the value returned from this function is an</span>
    <span class="co"># Option Monad holding the first word in the file (or Nothing)</span>
    .bind(<span class="kw">lambda</span> x: option_get_group(x, <span class="dv">1</span>))
    <span class="co"># We then bind our integer casting function.</span>
    <span class="co"># the value returned from this function is an</span>
    <span class="co"># Option Monad holding the integer it is cast to (or Nothing)</span>
    .bind(option_int))</code></pre></div>
<p>Side note: although whitespace is significant in Python, it is ignored inside of parenthesis, so if you ever need to split an expression onto multiple lines, you can surround it in parenthesis, as I have above.</p>
<p>This code opens a text file, reads the entire file from it, looks at the first word in the file, and tries to read it in as an integer. Using the Option Monad is useful because if an error happens at any time during the computation, it just passes a Nothing Option through the rest of the bind functions.</p>
<p>We can make this look cooler by choosing an infix operator to overload. By convention, <code>&gt;&gt;=</code> is used, but that's hard to to do in python, so we are going to use <code>&gt;&gt;</code>, a right shift. We can override that operator in python with the following code:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> <span class="fu">__rshift__</span>(<span class="va">self</span>, function):
    <span class="cf">return</span> <span class="va">self</span>.bind(function)</code></pre></div>
<p>Now, let's rewrite the above option code as the following.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">result <span class="op">=</span> (
    Option.some(<span class="st">&#39;text.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> option_open
      <span class="op">&gt;&gt;</span> option_read
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_get_group(x, <span class="dv">1</span>))
      <span class="op">&gt;&gt;</span> option_int
    )</code></pre></div>
<p>Consider the same operation in regular Python. We can write it in one expression, in which case this is impossible to read, or we can split it up, over many lines, creating a bunch of temporary variables that we use once and then never again.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># one expression</span>
result <span class="op">=</span> <span class="bu">int</span>(
        re.match(
            <span class="vs">r&#39;\s*(\S*)&#39;</span>,
            <span class="bu">open</span>(<span class="st">&#39;text.txt&#39;</span>).read()
        ).group(<span class="dv">1</span>)
    )

<span class="co"># with temporary variables</span>
temp1 <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;text.txt&#39;</span>).read()
temp2 <span class="op">=</span> re.match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, temp1).group(<span class="dv">1</span>)
result <span class="op">=</span> <span class="bu">int</span>(temp2)</code></pre></div>
<p>The first example is unreadable. The functions used have no meaningful order, so it becomes an act of mental gymnastics to figure out what happens when. The functions appear in the order <code>int</code>, <code>match</code>, <code>open</code>, <code>read</code>, and <code>group</code>. <code>int</code> comes first, despite being called last, and <code>open</code>, the first function to be called, appears randomly in the middle.</p>
<p>The second example is the shortest version where all the functions appear in the source code in the order they are called, and so it is pretty readable, but once again we've got the problem of errors!</p>
<p>This code could fail if the wrong information is passed into it, and it can fail in approximately 5 places. Even worse, because <code>.group()</code> can return <code>None</code> if it fails, and <code>int(None) == 0</code>, you can get a wrong answer from this code without an error being thrown. In order to guarantee that this code doesn't fail, we would have to rewrite it, and a solution like this would be necessary in Python.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
    temp1 <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;text.txt&#39;</span>).read()
    temp2 <span class="op">=</span> re.match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, temp1).group(<span class="dv">1</span>)
    <span class="cf">if</span> temp2 <span class="op">==</span> <span class="va">None</span>:
        result <span class="op">=</span> <span class="va">None</span>
    <span class="cf">else</span>:
        result <span class="op">=</span> <span class="bu">int</span>(temp2)
<span class="cf">except</span> <span class="pp">Exception</span>:
    result <span class="op">=</span> <span class="va">None</span></code></pre></div>
<p>The above code now won't throw any errors or produce erroneous results, and will set <code>result</code> to <code>None</code> if the code fails. Now, compare that safe version without Monads to the safe version with Monads.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">result <span class="op">=</span> (
    Option.some(<span class="st">&#39;text.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> option_open
      <span class="op">&gt;&gt;</span> option_read
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: option_get_group(x, <span class="dv">1</span>))
      <span class="op">&gt;&gt;</span> option_int
    )</code></pre></div>
<p>The Monad version is simpler, just as safe, and even a line shorter (two if you don't count the line with a single closing parenthesis). Not to mention cooler and more elegant by far.</p>
<h2 id="the-result-monad"><span class="header-section-number">3.2</span> The Result Monad</h2>
<p>There is one major problem with the Option monad above; if our code fails, we have no way to know how or when. With the standard python example, we could print an error message to the screen or to a file that would let us know what kind of error occurred. There is another Monad, called the Result Monad, that allows us to do just that while still having the power of the Option Monad. I won't reproduce the entire code here (it is in the appendix) but I will go over a few of the changes, as we will use the Result Monad in the next section.</p>
<p>The Result Monad uses slightly different names; a value is Ok if it is a successful computation, and it is an Error if the computation has failed. The functions that check this status are <code>self.is_ok()</code> and <code>self.is_error()</code>. <code>self.is_ok()</code> returns <code>True</code> if there is a value, and <code>False</code> if there is an error message. <code>self.is_error()</code> does the opposite.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Result:
    
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value, message):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._message <span class="op">=</span> message
        <span class="va">self</span>._value <span class="op">=</span> value</code></pre></div>
<p>Our <code>__init__</code> function now takes an additional argument; an error message. Now, we have a value that indicates whether or not our computation has failed, a value that stores the result of the computation (if the computation succeeded), and a value that stores the error message (if the computation failed).</p>
<p>In order to access the error message, we add a new function like <code>unwrap</code> from the Option Monad.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> error_msg(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>._message
        <span class="cf">else</span>:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Result is Ok&#39;</span>)</code></pre></div>
<p>This function checks whether or not we have failed, and returns the error message if it is an Error. Just like <code>unwrap</code>, it throws an Exception if there is no error message.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"></code></pre></div>
<p><code>bind</code> and <code>fmap</code> have not changed at all, but it is nice to note that when you return <code>self</code> in the case of the error, the error message stays the same. This means that when we chain multiple <code>bind</code> and <code>fmap</code> calls together, the first one that fails will have its error message propagate through till the end.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="co"># function operates on the value in the monad</span>
    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="co"># self is a Result Monad</span>
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="co"># function(val) is a value, so we have to wrap it</span>
        <span class="cf">return</span> Result.ok(function(val))
    <span class="co"># bind returns a Result Monad</span>

    <span class="co"># function returns a Result Monad</span>
    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="co"># self is a Result Monad</span>
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="co"># function(val) is a Result Monad</span>
        <span class="cf">return</span> function(val)
    <span class="co"># bind returns a Result Monad</span></code></pre></div>
<p>I'm also adding another function that is sort of like <code>bind</code>, but instead, provides a simple way for Monadic computations to check for errors, and if they've occurred, to replace the computed value with a default value. Instead of applying the function pass into <code>recover</code> to the value within the result, we call the function with no arguments, and it will return (by definition) a new Result Monad</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> recover(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> function()
        
        <span class="cf">return</span> <span class="va">self</span></code></pre></div>
<p>For example, if you wanted to write an app that read settings from a configuration file, you could write a function that did so, returning an Result Monad. Then you could <code>recover</code> with a function that provided the default settings for your app. That would mean that if everything worked fine, you would run your app with the settings from the file; however, if the file was missing, if parsing failed, or if some other error occurred, the recover function would automatically be called and the default value would be returned.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">config <span class="op">=</span> (
    result_open(<span class="st">&#39;config.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> result_read
      <span class="op">&gt;&gt;</span> result_parse
    ).recover(<span class="kw">lambda</span>: Result.ok(<span class="dv">10</span>))</code></pre></div>
<p>The equivalent in Python without Monads would be the following.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="cf">try</span>:
    temp1 <span class="op">=</span> <span class="bu">open</span>(<span class="st">&#39;config.txt&#39;</span>).read()
    config <span class="op">=</span> parse(temp1)
<span class="cf">except</span> <span class="pp">Exception</span>:
    config <span class="op">=</span> <span class="dv">10</span></code></pre></div>
<p>We've already seen the following constructors used above, but for completeness here are the two constructors for the Result Monad.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="at">@classmethod</span>
    <span class="kw">def</span> ok(cls, val):
        <span class="cf">return</span> cls(<span class="va">False</span>, val, <span class="va">None</span>)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> error(cls, msg):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>, msg)</code></pre></div>
<h1 id="a-parsing-monad"><span class="header-section-number">4</span> A Parsing Monad</h1>
<p>We're now going to talk about a Monad called the Parsing Combinator, which basically recreates and improves upon regular expressions, using Monads. Here we see the truth of the oft said but little understood aphorism that Monads represent computation; here, they represent the computation of regular expressions.</p>
<p>It's also worth noting that there are many python Parsing Combinator libraries on the python package index, and those will have faster, more powerful implementations than the one below.</p>
<h2 id="why"><span class="header-section-number">4.1</span> Why?</h2>
<p>The Parsing Combinator is going to seem a little pointless until we get to the examples, so I'd like to try and motivate it a bit. Parsing Combinators are, on the surface, similar to regular expressions, but they are more powerful in a few important ways.</p>
<p>First of all, while basic regular expressions can only handle regular languages, Parsing Combinators can match context sensitive languages. However, this is rarely important in practice, because most &quot;regular expressions&quot; in modern languages are likewise extended to be able to parse more complex languages.</p>
<p>Secondly, Parsing Combinators are more readable than regular expressions. Although regular expressions excel at concise and quick patterns, they can quickly become hard to read, like the following regular expression for floating point numbers: <code>[-+]? [0-9]* \.? [0-9]+ ([eE] [-+]? [0-9]+)?</code>. While this is concise and accurate, it is nevertheless hard to read, and impossible to understand if you don't already know regular expressions. And the example above is fairly simple.</p>
<p>Thirdly, Parsing Combinators allow for more than simple matching and finding substrings. Parsing Combinators allow you to transform the result of a match without leaving the Parsing Combinator; for instance, we could write a Parsing Combinator that found IP addresses in a text file, and then resolved the IP addresses into domain names, and then returned a list of the domain names, instead of simply returning the strings that matched.</p>
<p>Fourthly, Parsing Combinators can take advantage of compile time type checking in typed languages. While this isn't possible in Python, it is in many other languages. For example, the regular expression <code>[</code> is invalid; but most statically typed languages can't determine that it is invalid until runtime. Parsing Combinators, on the other hand, don't throw runtime exceptions like that; the information they encode is within the language itself, and therefore, they are checked at compile time to be valid.</p>
<p>Fifthly, they can be really fast. It's rare that a high level, very abstract language can claim to be as fast as low level languages, but there are cases when parsers written with the Parser Combinator Monad can rival or even beat the speed of parsers written in custom C. Obviously, the one I wrote for this next section is optimized for readability and not speed, but the interface is basically the same.</p>
<h2 id="the-code"><span class="header-section-number">4.2</span> The Code</h2>
<p>Unlike the Option Monad, I'm not going to go over the entire codebase for the Parsing Combinator. I hope to provide enough context so that the inner workings aren't mysterious, but there is a lot of code (all in the appendix) and it is frankly quite dull at times.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Parser:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, function):
        <span class="co"># function takes a string to be parsed and returns a Result Monad</span>
        <span class="co"># holding a tuple, holding (already_parsed_value, remainder_of_string) # or an Error</span>
        <span class="va">self</span>._function <span class="op">=</span> function
        
    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, text):
        <span class="cf">return</span> <span class="va">self</span>._function(text)</code></pre></div>
<p>The basic idea behind our Parsing Combinator is that it represents a function that takes an input text in, and outputs a Result Monad holding either an error, or a tuple containing the 'matched value' and the 'remaining text'. For example, a function that behaves like this would be:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> parse_hi(text):
    <span class="cf">try</span>:
        <span class="cf">if</span> text[<span class="dv">0</span>] <span class="op">==</span> <span class="st">&#39;h&#39;</span> <span class="op">and</span> text[<span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;i&#39;</span>:
            res <span class="op">=</span> Result.ok((<span class="st">&#39;hi&#39;</span>, text[<span class="dv">2</span>:]))
        <span class="cf">else</span>:
            res <span class="op">=</span> Result.error(<span class="st">&#39;The first two characters &#39;</span>
                                <span class="co">&#39;were not &quot;hi&quot;.&#39;</span>)
    <span class="cf">except</span> <span class="pp">IndexError</span>:
        res <span class="op">=</span> Result.error(<span class="st">&#39;The string is too short to &#39;</span>
                           <span class="co">&#39;contain &quot;hi&quot;.&#39;</span>)
    <span class="cf">return</span> res</code></pre></div>
<p>However, we want to use certain Monadic ideas like <code>bind</code> and <code>fmap</code> with our parser, so instead of just using functions like the above, we're going to wrap them with the <code>Parser</code> class, using <code>Parser(parse_hi)</code>. In order to still be able to call our function, we're going to implement the <code>__call__</code> method, which allows instances of our class to be called like functions. I've provided a small example of that below.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> DefaultPrinter:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, text):
        <span class="va">self</span>.text <span class="op">=</span> text
    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, arg<span class="op">=</span><span class="va">None</span>):
        <span class="cf">if</span> arg <span class="op">is</span> <span class="va">None</span>:
            <span class="bu">print</span>(<span class="va">self</span>.text)
        <span class="cf">else</span>:
            <span class="bu">print</span>(arg)

print_hi <span class="op">=</span> DefaultPrinter(<span class="st">&#39;hi&#39;</span>)
print_hi() <span class="co"># prints &#39;hi&#39;</span>
print_hi(<span class="st">&#39;other text&#39;</span>) <span class="co"># prints &#39;other text&#39;</span></code></pre></div>
<p>One of the ways we are going to interact with the Parsing Combinator is by combining a bunch of simple Parsers into one, large parser. As an example of a simple parser, let's look at one of the constructors for our parser.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># char is a single character</span>
<span class="co"># text is a string</span>
<span class="kw">def</span> match_char(char, text):
    <span class="cf">try</span>:
        current <span class="op">=</span> text[<span class="dv">0</span>]
    <span class="cf">except</span> <span class="pp">IndexError</span>:
        <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but &#39;</span> <span class="op">+</span>
            <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(char)))
    
    <span class="cf">if</span> current <span class="op">==</span> char:
        <span class="cf">return</span> Result.ok(
            (text[<span class="dv">0</span>],   <span class="co"># the character matched</span>
             text[<span class="dv">1</span>:])  <span class="co"># the remainder of the text</span>
        )
    <span class="cf">else</span>:
        <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to match character {} at {}&#39;</span>
            .<span class="bu">format</span>(<span class="bu">repr</span>(char), <span class="bu">repr</span>(text)))</code></pre></div>
<p>The above function takes a character and a text, checks whether the character is the first element of the text, and if it is, returns the matched character and the rest of the string as a tuple in a Result, and if not, it returns a error message in a Result. We can use this function to define an alternate constructor for the parser now:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="at">@classmethod</span>
    <span class="kw">def</span> char(cls, char):
        <span class="co"># char represents the character that our parser is going to match</span>
        <span class="cf">return</span> Parser(<span class="kw">lambda</span> text: match_char(char, text))</code></pre></div>
<p>The function we pass into the <code>Parser</code> constructor takes a single input, <code>text</code>, which will then be passed into <code>match_char</code> to be matched against the character we passed into the constructor (<code>char</code>).</p>
<p>We'll encounter other basic constructors later; for now, this will be enough to do a few basic examples.</p>
<p>In the next section, I am going to do something that isn't going to reflect how you would actually use monads. I'm going to use <code>bindp</code> for the <code>bind</code> function of a Parser Monad, and <code>bindr</code> for the <code>bind</code> function of a Result Monad.</p>
<p>To impress upon you how weird this is, and why you would never do it in actual code, is that <code>bind</code> represents a common interface all monads have; it would be like naming the addition and multiplication operators something different for <code>unsigned int</code>s, <code>signed int</code>s, <code>long</code>s, and <code>float</code>s.</p>
<p>However, it's very hard to read for the first time if all the binds look the same.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="co"># function takes a value, and returns a Result monad holding either the</span>
    <span class="co"># result of that function, or an error message.</span>
    <span class="kw">def</span> bindp(<span class="va">self</span>, function):
        
        <span class="co"># returned holds a tuple holding</span>
        <span class="co"># (currently matched value, remainder of source text)</span>
        <span class="kw">def</span> inner_function(returned):
            match <span class="op">=</span> returned[<span class="dv">0</span>]
            remainder <span class="op">=</span> returned[<span class="dv">1</span>]
            <span class="cf">return</span> function(match)
                .bindr(<span class="kw">lambda</span> x: Result.ok((x, remainder)))

        <span class="cf">return</span> Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text).bindr(inner))</code></pre></div>
<p><code>bindp</code> is, of course, the star of the show. From a high level, it is going to take a function (that might fail), and apply that function to the matched value of the Parser.</p>
<p>Let's break it down step by step. First, the <code>inner_function</code>:</p>
<ul>
<li><code>inner_function</code> takes a tuple containing the matched value and the remainder of the text. It's going to mostly ignore the remainder of the text.</li>
<li>Then, it applies the function (passed to <code>bindp</code>) to the matched value, transforming it into some other value. However, because it might fail, it returns a Result Monad holding that other value.</li>
<li>We want to return a Result Monad holding a tuple containing that other value and the remainder of the text, but the other value is in a Monad, so we need to either (a) manually pull it out, or (b) use bind.</li>
<li>We can use bind with <code>lambda x: Result.ok((x, remainder))</code> to pull the value x out of the Result Monad, and stick it back into a new Result Monad as the first member of the tuple we want.</li>
</ul>
<p>If we recall, <code>fmap</code> is very similar to <code>bind</code>, with the exception that the function passed to <code>fmap</code> is one we know isn't going to fail, and therefore doesn't return a Result Monad, just a simple value. Therefore, it requires slightly different handling. Luckily, since we know it won't fail, we can make it into a function that does return a Result Monad by simply wrapping it's return value in an <code>Result.Ok</code> monad.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bindp(<span class="kw">lambda</span> x: Result.ok(function(x)))</code></pre></div>
<p>We really don't have enough information yet to do anything interesting, but I'll still try to demonstrate an example of how <code>bind</code> or <code>fmap</code> might work.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># Here is a function that matches any character</span>
<span class="kw">def</span> any_char(text):
    <span class="cf">if</span> <span class="bu">len</span>(text) <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> Result.error(<span class="st">&quot;The text is too short&quot;</span>
                            <span class="co">&quot; to contain any character&quot;</span>)
    <span class="cf">else</span>:
        <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))

any_char_parser <span class="op">=</span> Parser(any_char)

<span class="bu">print</span>(any_char_parser(<span class="st">&#39;&#39;</span>))
<span class="co"># Result.Error(&quot;The text is too short to contain any character&quot;)</span>

<span class="bu">print</span>(any_char_parser(<span class="st">&#39;hello&#39;</span>))
<span class="co"># Result.Ok((&#39;h&#39;,&#39;ello&#39;))</span></code></pre></div>
<p>If I wanted to transform this value, I could define a new parser by <code>fmap</code>ing the <code>ord</code> function over it. <code>ord</code> is a built in python function that takes a single character and returns the ascii or unicode number it is associated with.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">ord_parser <span class="op">=</span> any_char_parser.fmap(<span class="bu">ord</span>)

<span class="bu">print</span>(ord_parser(<span class="st">&#39;&#39;</span>))
<span class="co"># Result.Error(&quot;The text is too short to contain any character&quot;)</span>

<span class="bu">print</span>(ord_parser(<span class="st">&#39;hello&#39;</span>))
<span class="co"># Ok((104, &#39;ello&#39;))</span></code></pre></div>
<p>As we can see above, <code>fmap</code> has altered the parsed value without altering the remainder of the text to be parsed.</p>
<p>Now that we've seen a way to construct this Monad, and how its <code>bind</code> and <code>fmap</code> functions work, let's look at how to combine simple Parsing Combinators into more complex ones.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="co"># self is a parser</span>
    <span class="co"># other is a parser</span>
    <span class="co"># function takes two values, and returns a new value</span>
    <span class="kw">def</span> combine(<span class="va">self</span>, other, function):
        
        <span class="kw">def</span> combine_func(returned):
            match <span class="op">=</span> returned[<span class="dv">0</span>] <span class="co"># the matched value from self</span>
            rest <span class="op">=</span> returned[<span class="dv">1</span>] <span class="co"># the remaining text from self</span>
            res <span class="op">=</span> other(rest) <span class="co"># pass the remaining text through other</span>
            
            <span class="co"># I could rewrite this using bind, but it</span>
            <span class="co"># just results in harder to read code, which is what</span>
            <span class="co"># we are trying to avoid.</span>
            <span class="cf">if</span> res.is_ok():
                other_match, other_rest <span class="op">=</span> res.unwrap()
                
                <span class="co"># we use function to combine the two matches into</span>
                <span class="co"># a new match, and then we put the new match back into</span>
                <span class="co"># context with the remaining text.</span>
                new_match <span class="op">=</span> function(match, other_match)
                <span class="cf">return</span> Result.ok((new_match, other_rest))
            <span class="cf">else</span>:
                <span class="cf">return</span> res
            
        <span class="cf">return</span> (
              Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text)
                .bindr( <span class="kw">lambda</span> res: combine_func(res) )
              )
            )</code></pre></div>
<p><code>combine</code> is the most useful function for us; it takes two parsers (<code>self</code> and <code>other</code>) and a function. It creates a new parser that first executes <code>self</code> on the input text, and then it executes <code>other</code> on the remaining text after <code>self</code>'s match. Then it uses <code>function</code> to combine the two matches, and returns that combination along with the remaining text from <code>other</code>'s match.</p>
<p>Once we have <code>combine</code> defined, we're going to create a bunch of other similar functions by calling <code>combine</code> with a default function to combine the two values.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> concat(<span class="va">self</span>, other):
        <span class="co"># think string concatenation for this plus, not</span>
        <span class="co"># addition of numbers.</span>
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: x <span class="op">+</span> y)
        
    <span class="kw">def</span> first(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: x)
    
    <span class="kw">def</span> last(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: y)
    
    <span class="kw">def</span> <span class="bu">tuple</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: (x,y))</code></pre></div>
<p>These functions are the most common choices for what you might want to use to combine the two matches. Most common is <code>concat</code>, which simply concatenates the two strings; this is the default regex behavior. Then there is <code>first</code> and <code>last</code>, which instead of combining the two values, instead discard one of the values. We will see later why this is useful. Finally, we can put the two values into a tuple instead of concatenating them, which is mostly useful when used in conjunction with <code>bind</code>. However, I've provided a few examples of working with these functions.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">match_a <span class="op">=</span> Parser.char(<span class="st">&#39;a&#39;</span>)
match_b <span class="op">=</span> Parser.char(<span class="st">&#39;b&#39;</span>)

<span class="co"># This will match the string &#39;ab&#39; and return the string &#39;ab&#39;</span>
match_a.concat(match_b)

<span class="co"># This will match the string &#39;ab&#39; and return the string &#39;a&#39;</span>
match_a.first(match_b)

<span class="co"># This will match the string &#39;ab&#39; and return the string &#39;b&#39;</span>
match_a.last(match_b)

<span class="co"># This will match the string &#39;ab&#39; and return the tuple (&#39;a&#39;,&#39;b&#39;)</span>
match_a.<span class="bu">tuple</span>(match_b)</code></pre></div>
<p>We also have a few other important functions that we use to build more complex parsers. I haven't included their code here, because I think that understanding <code>combine</code> is the most important code here, and I don't want to get bogged down in too many details.</p>
<p><code>choice</code> implements the ability to try one parser, and if it fails, recover by trying another. Be careful with this one, because it only operates locally. If you try and match <strong>x</strong> or <strong>y</strong>, and <strong>x</strong> succeeds in matching the text but puts you in a corner that causes failure later on, it won't backtrack and try <strong>y</strong>. It will only backtrack and try <strong>y</strong> if matching <strong>x</strong> fails. It is possible to alter this function so that it does backtrack, but it tends to not be required for writing powerful parsers.</p>
<p><code>many</code> is perhaps the most complicated constructor. What we want to do is continually match one parser, using a function to combine the results, until a failure occurs; but when a failure occurs, we want to ignore the failure and return that previous match. We also implement <code>many1</code> that matches one or more examples of an object, not zero or more like <code>many</code>.</p>
<p>There is also a variant of <code>many</code> called <code>many_list</code>, which instead of combining them by concatenating them, like <code>many</code> does, simply collects a list of all of the many matches.</p>
<p><code>optional</code> tries to match the input text with <code>self</code>, but if it fails, it matches nothing and returns the empty string as the match, and the whole text as the remainder.</p>
<p>Finally, we add symbolic versions of many of the above functions. This is purely for ease of reading the expressions we will write; you will see that they can get pretty complex, and <code>this.concat(that)</code> is less elegant than <code>this + that</code>.</p>
<p>Here is a full table of which functions I have bound to which symbols:</p>
<table>
<thead>
<tr class="header">
<th align="right">symbol</th>
<th>function</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right"><code>+</code></td>
<td><code>concat</code></td>
<td>concatenates the parsed values</td>
</tr>
<tr class="even">
<td align="right"><code>&lt;=</code></td>
<td><code>first</code></td>
<td>returns the parsed value of the first parser</td>
</tr>
<tr class="odd">
<td align="right"><code>&gt;=</code></td>
<td><code>last</code></td>
<td>returns the parsed value of the last parser</td>
</tr>
<tr class="even">
<td align="right"><code>&amp;</code></td>
<td><code>tuple</code></td>
<td>returns the parsed value of both parsers in a tuple</td>
</tr>
<tr class="odd">
<td align="right"><code>&gt;&gt;</code></td>
<td><code>bind</code></td>
<td>applies the function (which might fail) to the parsed value</td>
</tr>
<tr class="even">
<td align="right"><code>&gt;</code></td>
<td><code>fmap</code></td>
<td>applies the function to the parsed value</td>
</tr>
<tr class="odd">
<td align="right"><code>|</code></td>
<td><code>choice</code></td>
<td>tries the first parser, and if it fails, tries the second</td>
</tr>
</tbody>
</table>
<p>There are also a few more alternate constructors available, so here's a list of them and a brief description of what they do.</p>
<table>
<thead>
<tr class="header">
<th>constructor</th>
<th>description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>char</code></td>
<td>Matches the character that is passed into it</td>
</tr>
<tr class="even">
<td><code>oneof</code></td>
<td>Matches any one of the characters passed in as a string or list</td>
</tr>
<tr class="odd">
<td><code>empty</code></td>
<td>Matches nothing</td>
</tr>
<tr class="even">
<td><code>noneof</code></td>
<td>Matches any character not passed in as a string or list</td>
</tr>
</tbody>
</table>
<p>In order to use a parser, all we have to do is call it on some input. However, this will return a Result holding the matched value, remainder of text pair. I've also written a Parser method that will help streamline some parsing cases. Our normal parsing combinator doesn't care if it has reached the end of the input; if you have a parser that parses numbers, and you ask it to parse <code>'99 bottles of beer on the wall'</code>, it will happily parse the <code>99</code> and ignore the rest of the string; usually, we want the entire match, not just the first part. This function causes the result to be an error if the entire string isn't matched.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">    <span class="kw">def</span> parse_total(<span class="va">self</span>, string):
        
        <span class="kw">def</span> check_full(tup):
            <span class="co"># if there is no remaining text, return our matched value</span>
            <span class="cf">if</span> tup[<span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;&#39;</span>:
                <span class="cf">return</span> Result.ok(tup[<span class="dv">0</span>])
            <span class="co"># otherwise, there is an Error</span>
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;The match did not consist of the entire &#39;</span> <span class="op">+</span>
                    <span class="co">&#39;string: {} was left over&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(tup[<span class="dv">1</span>])))
            
        <span class="cf">return</span> <span class="va">self</span>(string).bindr(check_full)</code></pre></div>
<p>If you want to look at more of the code for context, it is included in the appendices of this paper.</p>
<h2 id="using-the-parser-combinator"><span class="header-section-number">4.3</span> Using the Parser Combinator</h2>
<p>Now we have a powerful enough Parser Monad to recreate all of the flexibility and power of regular expressions. We can combine parsers to make more complex ones, and we can transform the values within parsers, so let's try parsing something simple; let's try and write a Parser Combinator that parses numbers.</p>
<p>A number can be as simple as <code>12</code> or as complex as <code>12.00123e45</code>, so we're going to need to build up a complex parser. Let's start with creating a parser that parses 1 or more consecutive digits.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">digits <span class="op">=</span> Parser.oneof(<span class="st">&#39;0123456789&#39;</span>).many1()</code></pre></div>
<p>Now, we need to express an optional decimal place, followed by one of more digits. Remember, the <code>+</code> operator will use the first parser, and then the second parser, and concatenate their results.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">decimal <span class="op">=</span> (Parser.char(<span class="st">&#39;.&#39;</span>) <span class="op">+</span> digits).optional()</code></pre></div>
<p>Now, we need an exponent part, which is pretty simple given the above. However, we do need one additional component, a sign. The <code>|</code> operator will parse one or the other of the two things on either side of it.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">sign <span class="op">=</span> (Parser.char(<span class="st">&#39;+&#39;</span>) <span class="op">|</span> Parser.char(<span class="st">&#39;-&#39;</span>)).optional()
exponent <span class="op">=</span> (Parser.oneof(<span class="st">&#39;eE&#39;</span>) <span class="op">+</span> sign <span class="op">+</span> digits).optional()</code></pre></div>
<p>Finally, we can put these four together to get:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">number <span class="op">=</span> sign <span class="op">+</span> digits <span class="op">+</span> decimal <span class="op">+</span> exponent</code></pre></div>
<p>Here's our finished code, and it's results on some possible inputs:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">digits <span class="op">=</span> Parser.oneof(<span class="st">&#39;0123456789&#39;</span>).many1()
decimal <span class="op">=</span> (Parser.char(<span class="st">&#39;.&#39;</span>) <span class="op">+</span> digits).optional()
sign <span class="op">=</span> (Parser.char(<span class="st">&#39;+&#39;</span>) <span class="op">|</span> Parser.char(<span class="st">&#39;-&#39;</span>)).optional()
exponent <span class="op">=</span> (Parser.oneof(<span class="st">&#39;eE&#39;</span>) <span class="op">+</span> sign <span class="op">+</span> digits).optional()
number <span class="op">=</span> sign <span class="op">+</span> digits <span class="op">+</span> decimal <span class="op">+</span> exponent

Parser.parse_total(number, <span class="st">&#39;12&#39;</span>)
    <span class="co"># Ok(&#39;12&#39;)</span>
Parser.parse_total(number, <span class="st">&#39;12e10&#39;</span>)
    <span class="co"># Ok(&#39;12e10&#39;)</span>
Parser.parse_total(number, <span class="st">&#39;2.12345e100&#39;</span>)
    <span class="co"># Ok(&#39;2.12345e100&#39;)</span>
Parser.parse_total(number, <span class="st">&#39;hello world&#39;</span>)
    <span class="co"># Error(Failed to match one of</span>
    <span class="co"># [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;, &#39;6&#39;, &#39;7&#39;, &#39;8&#39;, &#39;9&#39;])</span>
Parser.parse_total(number, <span class="st">&#39;99 bottles of beer on the wall&#39;</span>)
    <span class="co"># Error(The match did not consist of the entire string:</span>
    <span class="co"># &#39; bottles of beer on the wall&#39; was left over)</span>
Parser.parse_total(number, <span class="st">&#39;&#39;</span>)
    <span class="co"># Error(End of String encountered)</span></code></pre></div>
<p>Furthermore, we can use a result-oriented version of python's <code>float</code> function, along with our <code>bind</code> operator, to cast these results to be floats instead of strings.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> result_float(x):
    <span class="cf">try</span>:
        <span class="cf">return</span> Result.ok(<span class="bu">float</span>(x))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to cast to a float&#39;</span>)

Parser.parse_total(number, <span class="st">&#39;7.22345e10&#39;</span>) <span class="op">&gt;&gt;</span> result_float
    <span class="co"># Ok(72234500000.0)</span></code></pre></div>
<h2 id="going-further"><span class="header-section-number">4.4</span> Going Further</h2>
<p>Everything we've done so far can basically be done in the exact same way by regular expressions. However, because of the way we've defined the Parsing Combinator, we can use <code>bind</code> and <code>fmap</code> inside of Parsing Combinator expressions. This allows us to parse complex expressions into fully formed and entirely arbitrary python objects.</p>
<h3 id="list-of-numbers-parser"><span class="header-section-number">4.4.1</span> List of Numbers Parser</h3>
<p>Before, we matched a string using our parser, producing a Result Monad. We then used <code>bind</code> to transform the value the Parser returned into an actual number. However, the Parser is also a Monad, so we can move the <code>bind</code> call into the parser itself, and it won't change the way it works.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">number <span class="op">=</span> (sign <span class="op">+</span> digits <span class="op">+</span> decimal <span class="op">+</span> exponent) <span class="op">&gt;&gt;</span> result_float

<span class="co"># whitespace consists of a space, a tab, or a newline</span>
whitespace <span class="op">=</span> Parser.oneof(<span class="st">&#39; </span><span class="ch">\t\n</span><span class="st">&#39;</span>).many1()

<span class="co"># without infix operators</span>
many_numbers <span class="op">=</span> (
        (whitespace.optional().last(number))
    ).many_list()

<span class="co"># with infix operators</span>
many_numbers <span class="op">=</span> (
        (whitespace.optional() <span class="op">&gt;=</span> number)
    ).many_list()</code></pre></div>
<p>Let me take this code and expand it into English. <code>many_numbers</code> translates to 'If there's any whitespace, match it and discard it, and parse a number following it. Then, put that number in a list, and repeat until parsing fails, appending new numbers to the list, and return that.'</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">text <span class="op">=</span> <span class="st">&#39;2.12345e+100 2.1e10 1223 13.5 100e100&#39;</span>
<span class="bu">print</span>(Parser.parse_total(many_numbers, text))
<span class="co"># Ok([2.12345e+100, 21000000000.0, 1223.0, 13.5, 1e+102])</span></code></pre></div>
<h3 id="csv-parser"><span class="header-section-number">4.4.2</span> CSV Parser</h3>
<p>Parsing Combinators can be used to write powerful, modular, readable, and concise parsers for any format of text. One common way of representing values in text is the CSV file format; this format is used to represent tables in pure text. The columns are separated by commas, and the rows are separated by newlines. Below is a CSV parser in 5 lines of code.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">expression <span class="op">=</span> Parser.noneof(<span class="st">&#39;,</span><span class="ch">\n</span><span class="st">&#39;</span>).many1()
comma <span class="op">=</span> Parser.char(<span class="st">&#39;,&#39;</span>)
newline <span class="op">=</span> Parser.char(<span class="st">&#39;</span><span class="ch">\n</span><span class="st">&#39;</span>)
line <span class="op">=</span> (expression <span class="op">&lt;=</span> comma.optional()).many_list()
csv <span class="op">=</span> (line <span class="op">&lt;=</span> newline.optional()).many_list()

<span class="co"># Example</span>
text <span class="op">=</span> <span class="st">&#39;&#39;&#39;1,2,3,4,5</span>
<span class="st">hello world, my, good, friends, 5</span>
<span class="st">0,1,2,3,4&#39;&#39;&#39;</span>

<span class="bu">print</span>(csv.parse_total(text))
<span class="co"># Ok(</span>
<span class="co">#     [</span>
<span class="co">#         [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;, &#39;5&#39;],</span>
<span class="co">#         [&#39;hello world&#39;, &#39; my&#39;, &#39; good&#39;, &#39; friends&#39;, &#39; 5&#39;],</span>
<span class="co">#         [&#39;0&#39;, &#39;1&#39;, &#39;2&#39;, &#39;3&#39;, &#39;4&#39;]</span>
<span class="co">#     ]</span>
<span class="co"># )</span></code></pre></div>
<p>First, we define a parser for the data we actually care about; the data we're talking about can be any text as long as it doesn't contain a newline or a comma.</p>
<p>Next, we create simple comma and newline parsers. This isn't really necessary; I just think it makes it easier to read.</p>
<p>Then, we will define a line parser to be an expression, followed by a comma, over and over. This Parser will match until it comes to a newline, at which point it will stop, because nothing in the Parser can deal with a newline.</p>
<p>In order to match the whole csv, we will match a line, followed by a newline character, over and over. And then when we pass some data into the CSV, it will parse it into a list of rows, each of which is a list of the values in those rows.</p>
<h3 id="abstract-syntax-tree-parser"><span class="header-section-number">4.4.3</span> Abstract Syntax Tree Parser</h3>
<p>This next section requires a bit of domain knowledge; we're going to parse basic mathematical expressions into something called an Abstract Syntax Tree, or AST. An AST is behind the interpreter or compiler for almost every language, so parsing them is a common thing to want to do. In our case, we are parsing a simple language of addition, subtraction, multiplication, and division, and using parenthesis to let our expression contain a smaller expression.</p>
<p>The parser that we will construct is going to return a tree like recursive data structure in Python, holding the full structure of the text we pass in. In order to do this recursively, I will not be able to do everything with the constructors and combination functions; instead, I will have to write a new function and pass that explicitly to the default Parser constructor.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="im">from</span> enum <span class="im">import</span> Enum, auto

<span class="co"># This is just a basic Enumeration in Python</span>
<span class="kw">class</span> Op(Enum):
    PLUS <span class="op">=</span> auto()
    MINUS <span class="op">=</span> auto()
    TIMES <span class="op">=</span> auto()
    DIV <span class="op">=</span> auto()

<span class="kw">class</span> Expr:
    <span class="kw">def</span> <span class="fu">__init__</span>(expr1, op, expr2):
        <span class="va">self</span>.expr1 <span class="op">=</span> expr1
        <span class="va">self</span>.expr2 <span class="op">=</span> expr2
        
        <span class="cf">if</span> op <span class="op">==</span> <span class="st">&#39;+&#39;</span>:
            <span class="va">self</span>.op <span class="op">=</span> Op.PLUS
        <span class="cf">elif</span> op <span class="op">==</span> <span class="st">&#39;-&#39;</span>:
            <span class="va">self</span>.op <span class="op">=</span> Op.MINUS
        <span class="cf">elif</span> op <span class="op">==</span> <span class="st">&#39;*&#39;</span>:
            <span class="va">self</span>.op <span class="op">=</span> Op.TIMES
        <span class="cf">elif</span> op <span class="op">==</span> <span class="st">&#39;/&#39;</span>:
            <span class="va">self</span>.op <span class="op">=</span> Op.DIV
        <span class="cf">else</span>:
            <span class="va">self</span>.op <span class="op">=</span> op
    
    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> (<span class="st">&quot;Expr({}, {}, {})&quot;</span>
            .<span class="bu">format</span>(<span class="va">self</span>.expr1, <span class="va">self</span>.op, <span class="va">self</span>.expr2))

<span class="co"># this function surrounds a parser with optional whitespace</span>
<span class="kw">def</span> pad(parser):
    <span class="cf">return</span> (whitespace.optional() <span class="op">&gt;=</span> parser) <span class="op">&lt;=</span> whitespace.optional()

<span class="co"># we create a bunch of symbols for our parser which</span>
<span class="co"># all can be surrounded by whitespace</span>
openp <span class="op">=</span> pad(Parser.char(<span class="st">&#39;(&#39;</span>))
closep <span class="op">=</span> pad(Parser.char(<span class="st">&#39;)&#39;</span>))

plus <span class="op">=</span> pad(Parser.char(<span class="st">&#39;+&#39;</span>))
minus <span class="op">=</span> pad(Parser.char(<span class="st">&#39;-&#39;</span>))
times <span class="op">=</span> pad(Parser.char(<span class="st">&#39;*&#39;</span>))
div <span class="op">=</span> pad(Parser.char(<span class="st">&#39;/&#39;</span>))
operator <span class="op">=</span> plus <span class="op">|</span> minus <span class="op">|</span> times <span class="op">|</span> div

<span class="co"># this function surrounds a parser with a pair of parens</span>
<span class="kw">def</span> surround(parser):
    <span class="cf">return</span> (openp <span class="op">&gt;=</span> parser) <span class="op">&lt;=</span> closep

<span class="kw">def</span> expr(text):
    recursive <span class="op">=</span> Parser(expr)
    
    expression <span class="op">=</span> surround(
        (recursive <span class="op">|</span> number)
        <span class="op">&amp;</span> operator
        <span class="op">&amp;</span> (recursive <span class="op">|</span> number)
    )
    
    <span class="co"># things parsed by expression will have the slightly ugly form</span>
    <span class="co"># of Ok(((a,b),c)). To transform that into an Ok(Expr)</span>
    <span class="co"># we will define the following function:</span>
    weird_func <span class="op">=</span> <span class="kw">lambda</span> weird_tuple: Expr(
                        weird_tuple[<span class="dv">0</span>][<span class="dv">0</span>],
                        weird_tuple[<span class="dv">0</span>][<span class="dv">1</span>],
                        weird_tuple[<span class="dv">1</span>]
                    )
    
    <span class="co"># we use fmap to apply the above function to</span>
    <span class="co"># the matched value of the parser</span>
    full <span class="op">=</span> expression <span class="op">&gt;</span> weird_func
    
    <span class="cf">return</span> full(text)

text <span class="op">=</span> <span class="st">&#39;((1+2) * (9 - 11))&#39;</span>

<span class="bu">print</span>(Parser(expr).parse_total(text))
<span class="co"># Ok(</span>
<span class="co">#     Expr(</span>
<span class="co">#         Expr(</span>
<span class="co">#             1.0,</span>
<span class="co">#             Op.PLUS,</span>
<span class="co">#             2.0</span>
<span class="co">#         ),</span>
<span class="co">#         Op.TIMES,</span>
<span class="co">#         Expr(</span>
<span class="co">#             9.0,</span>
<span class="co">#             Op.MINUS,</span>
<span class="co">#             11.0</span>
<span class="co">#         )</span>
<span class="co">#     )</span>
<span class="co"># )</span></code></pre></div>
<p>I decided to reproduce this sort of code using standard regular expressions; Not only did my regex version have twice as many lines, it was a much more fragile program. I didn't thoroughly test it, but I didn't even bother adding error checking if stuff went wrong; I just assumed everything would go right. Furthermore, there were nested loops, plenty of functions, and all in all complex, messy, hard to read code. The Parsing Combinator above, however, is short and will always return an Error Result with a sensible error message if an error happens.</p>
<h1 id="theory-of-monads"><span class="header-section-number">5</span> Theory of Monads</h1>
<p>Now that we've seen a few examples of what a Monad is, we can talk about the formal definition. This is going to be the most abstract section of the text, but I'll try and keep any statements from category theory or abstract algebra from appearing here.</p>
<h2 id="defining-monads"><span class="header-section-number">5.1</span> Defining Monads</h2>
<p>Monads are a special type of object that contains with in it a value and a context. Our Option and Result Monads contained the result of a computation, along with contextual information regarding whether the operation had succeeded or failed. This allowed us to write programs that could detect failure elegantly. Our Parsing Monad contained the result of the parsing so far, as well as the rest of the text remaining to be parsed. Whenever you see a Monad, you can sum up its operation by asking &quot;What is the value in this Monad, and what is the context?&quot;. Many people, when confronted with Monads, want a way to get the value out of the Monad. But this causes problems, because you've taken the value out of context, and it becomes significantly more useless.</p>
<p>In order to interact with the values without taking them out of their context, we have a function called <code>fmap</code>. <code>fmap</code> takes the value, and applies the function to that value, and puts the result of the function back into context. In our Option and Result Monads, it applied the function to the value if our computation was successful, or it simply bypassed the function if our computation had failed. In our parsing combinator, it applied the function to the result of our computation, while leaving the remainder of the text to be parsed alone.</p>
<p>However, this meant that we couldn't use functions on the values in our Monad if the functions themselves returned Monads. For our Option and Result Monads, that means that we couldn't use a function that could fail (a function that returned an Option or Result Monad) on our Monad with <code>fmap</code>. If we did that, we could end up with a recursive Monad, like <code>Some(None)</code> or <code>Some(Some(3))</code>. This is annoying, and there's two ways to fix this weirdness.</p>
<p>The first way, which we used in the previous section, is to use a function called <code>bind</code>. <code>bind</code> is the same as <code>fmap</code>, but instead of putting the return value of the function passed to <code>bind</code> back into the same context, it expects that <code>bind</code> will return a new value and context (a Monad of some kind).</p>
<p>The second way is an alternative to <code>bind</code>; you don't need both, and it's more common to have <code>bind</code> as the one to use, so I haven't bothered talking about it yet. This function is called <code>join</code>, and it takes a recursive Monad and flattens it from two layers to one layer. For example:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Option.some(Option.some(x)).join() <span class="op">==</span> Option.some(x)
Option.some(Option.none()).join() <span class="op">==</span> Option.none()
Option.none().join() <span class="op">==</span> Option.none()</code></pre></div>
<p>We can show that <code>join</code> isn't any less useful than <code>bind</code> by actually writing <code>bind</code> using only <code>join</code> and <code>fmap</code>.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> bind(monad, function):
    <span class="cf">return</span> monad.fmap(function).join()</code></pre></div>
<p>This does the same thing as <code>bind</code> usually does; it applies the function to the inside value if the Monad isn't Nothing, and then it returns Nothing if either the function returns or the Monad is Nothing, or it returns Some(value) if the function succeeds and the Monad had a value to pass into the function.</p>
<p>We can also show a way to write <code>fmap</code> and <code>join</code> solely using <code>bind</code>:</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> fmap(monad, function):
    monad.bind(<span class="kw">lambda</span> x: Option.some(function(x)))

<span class="kw">def</span> join(monad):
    monad.bind(<span class="kw">lambda</span> x: x.unwrap() <span class="cf">if</span> x.is_some() <span class="cf">else</span> x)</code></pre></div>
<p>This means, for our purposes, for something to be a Monad, we require it to either have both <code>fmap</code> <em>and</em> <code>join</code>, or just <code>bind</code>. However, it is common for Monads to have all three available.</p>
<h2 id="monad-laws"><span class="header-section-number">5.2</span> Monad Laws</h2>
<p>Now, Monads have three laws, or rules, they have to follow; this is just to make sure Monads don't have any unexpected behavior, but we should go over those rules anyway.</p>
<p>First of all, if you <code>fmap</code> over a Monad with the identity function (a function that returns its inputs unchanged), the value in the Monad doesn't change.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Monad(x).fmap(<span class="kw">lambda</span> x: x) <span class="op">==</span> Monad(x)</code></pre></div>
<p>Secondly, if you <code>fmap</code> two functions in a row, it should be the same as simply <code>fmap</code>ing the function which does the equivalent of those two functions in order.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">m.fmap(<span class="kw">lambda</span> x: x<span class="dv">+1</span>).fmap(<span class="kw">lambda</span> x: x<span class="dv">+2</span>) <span class="op">==</span> m.fmap(<span class="kw">lambda</span> x: x<span class="dv">+3</span>)</code></pre></div>
<p>Finally, if you apply a function to a value and then stick it in a Monad, it is the same as putting that value in a Monad and <code>fmap</code>ing that function.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python">Monad(x).fmap(f) <span class="op">==</span> Monad(f(x))</code></pre></div>
<p>If you want, you can put these rules into equivalent forms using <code>bind</code> instead of <code>fmap</code>.</p>
<p>These might seem common sense, and if they are, that's good! The only reason that we require that these rules are followed is so that somebody doesn't create a Monad that behaves weirdly and it screws up our program. They basically boil down to &quot;Monads should behave sensibly when you fmap or bind functions over them&quot;.</p>
<h1 id="more-monad-examples"><span class="header-section-number">6</span> More Monad Examples</h1>
<h2 id="the-zeroth-monad"><span class="header-section-number">6.1</span> The Zeroth Monad</h2>
<p>Our first section was titled 'Our First Monad'. However, we are computer scientists, and therefore we start counting at zero, not at one. So let's talk about another Monad that everyone reading this document has probably used, but never noticed that it was a Monad.</p>
<p>Lists.</p>
<p>How is a list a Monad? Well, from the previous section, a Monad is really just anything with a <code>bind</code> function, or with a <code>fmap</code> and a <code>join</code> function. And while not every programming language has these functions built in, we can easily write these functions for a list.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="co"># python has a built in function, &#39;map&#39; that does this.</span>
<span class="kw">def</span> fmap(ls, function):
    new <span class="op">=</span> []
    <span class="cf">for</span> item <span class="op">in</span> ls:
        new.append(function(item))
    <span class="cf">return</span> new

<span class="co"># this is sometimes called &#39;flatten&#39;</span>
<span class="kw">def</span> join(ls):
    new <span class="op">=</span> []
    <span class="cf">for</span> sublist <span class="op">in</span> ls:
        <span class="cf">for</span> item <span class="op">in</span> sublist:
            new.append(item)
    <span class="cf">return</span> new

<span class="co"># bind can be defined entirely with the other two!</span>
<span class="kw">def</span> bind(ls, function):
    <span class="cf">return</span> join(fmap(ls, function))</code></pre></div>
<p>This is all nice and well that we now have these functions, but it explains little conceptually. So let's try and describe Monads conceptually, and see how that can be applied to lists.</p>
<p>Our first Monads, the Option Monad and the Result Monad, both represented some sort of computation result that required more context than a simple value; in particular, they represented a computation result that could either succeed, producing a value, or fail, producing no meaningful value.</p>
<p>Lists can be thought of in a similar way; instead of representing either zero or one meaningful return value, lists can represent computations that can return zero, one, or any possible number of return values. For example, consider the following contrived example.</p>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">def</span> abs_less_than(x):
    <span class="cf">if</span> x <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> []
    ls <span class="op">=</span> [<span class="dv">0</span>]
    <span class="cf">for</span> i <span class="op">in</span> <span class="bu">range</span>(<span class="dv">1</span>,x):
        ls.append(i)
        ls.append(<span class="op">-</span>i)
    <span class="cf">return</span> ls

abs_less_than(<span class="dv">1</span>) <span class="co"># [0]</span>
abs_less_than(<span class="dv">3</span>) <span class="co"># [0,-1,1,-2,2]</span>

<span class="im">from</span> math <span class="im">import</span> sqrt

<span class="kw">def</span> sqrts(x):
    <span class="cf">if</span> x <span class="op">&lt;</span> <span class="dv">0</span>:
        <span class="cf">return</span> []
    <span class="cf">elif</span> x <span class="op">==</span> <span class="dv">0</span>:
        <span class="cf">return</span> [<span class="fl">0.0</span>]
    <span class="cf">else</span>:
        <span class="cf">return</span> [sqrt(x), <span class="op">-</span>sqrt(x)]
        
sqrts(<span class="dv">4</span>) <span class="co"># [-2, 2]</span>
sqrts(<span class="op">-</span><span class="dv">4</span>) <span class="co"># []</span>

bind(
    bind(
        <span class="co"># we make a monad holding 3</span>
        [<span class="dv">3</span>],
        <span class="co"># and we bind abs_less_than over it</span>
        abs_less_than
    ),
    <span class="co"># and then bind sqrts over it</span>
    sqrts
)
<span class="co"># [0.0, 1.0, -1.0, 1.4142135623730951, -1.4142135623730951]</span></code></pre></div>
<p>In this case, we execute two functions in series, getting all of the valid results to our question in one list; but the number of results isn't the same for all inputs, so we need a Monad to represent this computational uncertainty.</p>
<h2 id="promises-in-javascript"><span class="header-section-number">6.2</span> Promises (in Javascript)</h2>
<p>As I was writing this essay, I started working on a project in Javascript that ended up using a thing called Promises. In Javascript, it's common to call a function that will perform some action, wait for something else to respond to the action, and then respond to that response. This is traditionally done with callbacks: passing a function into another function.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// setTimeout waits for 3000 ms, and then</span>
<span class="co">// calls the function you passed it.</span>
<span class="at">setTimeout</span>(
    <span class="kw">function</span>()<span class="op">{</span>
        <span class="at">alert</span>(<span class="st">&quot;Hello&quot;</span>)<span class="op">;</span>
    <span class="op">},</span>
    <span class="dv">3000</span>
)<span class="op">;</span></code></pre></div>
<p>However, if the function you pass in needs to call another function that uses a callback, this can quickly lead to <em>callback hell</em>.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="co">// don&#39;t bother trying to understand this;</span>
<span class="co">// it&#39;s just an illustrative example</span>
<span class="kw">function</span> <span class="at">handler</span> () <span class="op">{</span>
  <span class="co">// validateParams takes a function</span>
  <span class="at">validateParams</span>((err) <span class="op">=&gt;</span> <span class="op">{</span>
    <span class="cf">if</span> (err) <span class="op">{</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Error:&#39;</span><span class="op">,</span> err)<span class="op">;</span> <span class="cf">return</span> <span class="op">}</span>
    <span class="co">// dbQuery takes a function</span>
    <span class="at">dbQuery</span>((err<span class="op">,</span> dbResults) <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="cf">if</span> (err) <span class="op">{</span> <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Error:&#39;</span><span class="op">,</span> err)<span class="op">;</span> <span class="cf">return</span> <span class="op">}</span>
      <span class="co">// serviceCall takes a function</span>
      <span class="at">serviceCall</span>(dbResults<span class="op">,</span> (err<span class="op">,</span> serviceResults) <span class="op">=&gt;</span> <span class="op">{</span>
        <span class="co">//do something here!</span>
      <span class="op">}</span>)
    <span class="op">}</span>)
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<p>In modern javascript, there is a new feature: Promises! Promises intend to make the above code significantly easier to read; instead of passing in a function to provide a response, the function returns a Promise object you simply call the <code>then</code> method and pass in another function that returns a Promise object.</p>
<div class="sourceCode"><pre class="sourceCode javascript"><code class="sourceCode javascript"><span class="kw">function</span> <span class="at">handler</span> (done) <span class="op">{</span>  
  <span class="co">// validateParams returns a promise</span>
  <span class="cf">return</span> <span class="at">validateParams</span>()
    .<span class="at">then</span>(dbQuery)
    .<span class="at">then</span>(serviceCall)
    .<span class="at">then</span>( <span class="co">/* do something here! */</span> )
    .<span class="at">catch</span>((err) <span class="op">=&gt;</span> <span class="op">{</span>
      <span class="va">console</span>.<span class="at">log</span>(<span class="st">&#39;Error:&#39;</span><span class="op">,</span> err)
  <span class="op">}</span>)
<span class="op">}</span></code></pre></div>
<p>Look familiar? That's right; Promises are essentially Result Monads with <code>bind</code> renamed as <code>then</code>, <code>recover</code> renamed as <code>catch</code>, and with a different underlying implementation (one that makes it impossible to define a <code>unwrap</code> operation, but then again, it's rare to actually need that). This is intentional. The people who designed Promises knew what Monads are, and knew how they could be used to fix a problem with Javascript.</p>

<p></p>
<h1 id="code-the-result-monad"><span class="header-section-number">7</span> Code: The Result Monad</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Result:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, failed, value, message):
        <span class="va">self</span>._failed <span class="op">=</span> failed
        <span class="va">self</span>._message <span class="op">=</span> message
        <span class="va">self</span>._value <span class="op">=</span> value

    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Option.error({})&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(<span class="va">self</span>._message))
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Option.ok({})&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(<span class="va">self</span>._value))

    <span class="kw">def</span> <span class="fu">__str__</span>(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="st">&#39;Error({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._message)
        <span class="cf">else</span>:
            <span class="cf">return</span> <span class="st">&#39;Ok({})&#39;</span>.<span class="bu">format</span>(<span class="va">self</span>._value)

    <span class="kw">def</span> is_ok(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>._failed:
            <span class="cf">return</span> <span class="va">False</span>
        <span class="cf">return</span> <span class="va">True</span>

    <span class="kw">def</span> is_error(<span class="va">self</span>):
        <span class="cf">return</span> <span class="op">not</span> <span class="va">self</span>.is_ok()
    
    <span class="kw">def</span> unwrap(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.is_ok():
            <span class="cf">return</span> <span class="va">self</span>._value
        <span class="cf">else</span>:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Result is an Error&#39;</span>)
    
    <span class="kw">def</span> error_msg(<span class="va">self</span>):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>._message
        <span class="cf">else</span>:
            <span class="cf">raise</span> <span class="pp">Exception</span>(<span class="st">&#39;This Result is Ok&#39;</span>)
            
    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="cf">return</span> function(val)
        
    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> <span class="va">self</span>
        
        val <span class="op">=</span> <span class="va">self</span>.unwrap()
        <span class="cf">return</span> Result.ok(function(val))
    
    <span class="kw">def</span> recover(<span class="va">self</span>, function):
        <span class="cf">if</span> <span class="va">self</span>.is_error():
            <span class="cf">return</span> function()
        
        <span class="cf">return</span> <span class="va">self</span>
    
    <span class="kw">def</span> <span class="fu">__rshift__</span>(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bind(function)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> ok(cls, val):
        <span class="cf">return</span> cls(<span class="va">False</span>, val, <span class="va">None</span>)
    
    <span class="at">@classmethod</span>
    <span class="kw">def</span> error(cls, msg):
        <span class="cf">return</span> cls(<span class="va">True</span>, <span class="va">None</span>, msg)

<span class="co"># The following are built in functions</span>
<span class="co"># rewritten to work with the Result Monad</span>

<span class="kw">def</span> result_open(filename, mode<span class="op">=</span><span class="st">&#39;r&#39;</span>):
    <span class="cf">try</span>:
        fd <span class="op">=</span> Result.ok(<span class="bu">open</span>(filename, mode<span class="op">=</span>mode))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        fd <span class="op">=</span> Result.error(<span class="st">&quot;Failed to open the file&quot;</span>)
    <span class="cf">return</span> fd

<span class="kw">def</span> result_read(fd, size<span class="op">=-</span><span class="dv">1</span>):
    <span class="cf">try</span>:
        data <span class="op">=</span> Result.ok(fd.read(size))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        data <span class="op">=</span> Result.error(<span class="st">&quot;Failed to read from the file&quot;</span>)
    <span class="cf">return</span> data

<span class="im">import</span> re

<span class="kw">def</span> result_match(pattern, string):
    match <span class="op">=</span> re.match(pattern, string)
    <span class="cf">if</span> match:
        match <span class="op">=</span> Result.ok(match)
    <span class="cf">else</span>:
        match <span class="op">=</span> Result.error(<span class="st">&quot;Failed to match the pattern&quot;</span>)
    <span class="cf">return</span> match

<span class="kw">def</span> result_get_group(match, group):
    <span class="cf">try</span>:
        g <span class="op">=</span> match.group(group)
    <span class="cf">except</span> <span class="pp">Exception</span>:
        g <span class="op">=</span> <span class="va">None</span>

    <span class="cf">if</span> g <span class="op">==</span> <span class="va">None</span>:
        g <span class="op">=</span> Result.error(<span class="st">&quot;Failed to get the group from the match&quot;</span>)
    <span class="cf">else</span>:
        g <span class="op">=</span> Result.ok(g)
        
    <span class="cf">return</span> g

<span class="kw">def</span> result_int(s):
    <span class="cf">try</span>:
        i <span class="op">=</span> Result.ok(<span class="bu">int</span>(s))
    <span class="cf">except</span> <span class="pp">Exception</span>:
        i <span class="op">=</span> Result.error(<span class="st">&quot;Failed to parse into an integer&quot;</span>)
    <span class="cf">return</span> i


result <span class="op">=</span> (
    Result.ok(<span class="st">&#39;text.txt&#39;</span>)
      <span class="op">&gt;&gt;</span> result_open
      <span class="op">&gt;&gt;</span> result_read
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: result_match(<span class="vs">r&#39;\s*(\S*)&#39;</span>, x))
      <span class="op">&gt;&gt;</span> (<span class="kw">lambda</span> x: result_get_group(x, <span class="dv">1</span>))
      <span class="op">&gt;&gt;</span> result_int
    )

<span class="bu">print</span>(result)</code></pre></div>
<h1 id="code-the-parsing-combinator"><span class="header-section-number">8</span> Code: The Parsing Combinator</h1>
<div class="sourceCode"><pre class="sourceCode python"><code class="sourceCode python"><span class="kw">class</span> Parser:
    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, function):
        <span class="va">self</span>._function <span class="op">=</span> function
        
    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, text):
        x <span class="op">=</span> <span class="va">self</span>._function(text)
        <span class="cf">return</span> x

    <span class="kw">def</span> <span class="fu">__repr__</span>(<span class="va">self</span>):
        <span class="cf">return</span> <span class="st">&#39;&lt;Parsing Combinator&gt;&#39;</span>
            
    <span class="kw">def</span> bind(<span class="va">self</span>, function):
        
        <span class="kw">def</span> bind_func(result):
            <span class="cf">return</span> function(result[<span class="dv">0</span>]).bind(<span class="kw">lambda</span> x: Result.ok((x, result[<span class="dv">1</span>])))

        <span class="cf">return</span> Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text).bind(bind_func))
    
    <span class="kw">def</span> fmap(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bind(<span class="kw">lambda</span> x: Result.ok(function(x)))
    
    <span class="kw">def</span> combine(<span class="va">self</span>, other, function):
        
        <span class="kw">def</span> combine_func(match, rest):
            res <span class="op">=</span> other(rest)
            <span class="cf">if</span> res.is_ok():
                other_match, rest <span class="op">=</span> res.unwrap()
                new_match <span class="op">=</span> function(match, other_match)
                <span class="cf">return</span> Result.ok((new_match, rest))
            <span class="cf">else</span>:
                <span class="cf">return</span> res
            
        <span class="cf">return</span> Parser(<span class="kw">lambda</span> text: <span class="va">self</span>(text).bind(<span class="kw">lambda</span> res: combine_func(<span class="op">*</span>res)))
    
    <span class="kw">def</span> concat(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x, y: x <span class="op">+</span> y)
    
    <span class="kw">def</span> choice(<span class="va">self</span>,other):
        
        <span class="kw">def</span> choice_func(text):
            <span class="cf">return</span> <span class="va">self</span>(text).recover(<span class="kw">lambda</span>: other(text))
        
        <span class="cf">return</span> Parser(choice_func)
    
    <span class="kw">def</span> many(<span class="va">self</span>, function<span class="op">=</span><span class="kw">lambda</span> x,y: x <span class="op">+</span> y):
        
        <span class="kw">def</span> repeat_func(text):
            res <span class="op">=</span> <span class="va">self</span>(text)
            
            <span class="cf">if</span> res.is_error():
                <span class="cf">return</span> Result.ok((<span class="st">&#39;&#39;</span>,text))
            
            match <span class="op">=</span> res.unwrap()[<span class="dv">0</span>]
            rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
            
            res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">while</span> res.is_ok():
                match <span class="op">=</span> function(match, res.unwrap()[<span class="dv">0</span>])
                rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
                res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">return</span> Result.ok((match, rest))
            
        <span class="cf">return</span> Parser(repeat_func)
    
    <span class="kw">def</span> many_list(<span class="va">self</span>):
        
        <span class="kw">def</span> repeat_func(text):
            res <span class="op">=</span> <span class="va">self</span>(text)
            
            <span class="cf">if</span> res.is_error():
                <span class="cf">return</span> Result.ok((<span class="st">&#39;&#39;</span>,text))
            
            match <span class="op">=</span> [res.unwrap()[<span class="dv">0</span>]]
            rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
            
            res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">while</span> res.is_ok():
                match <span class="op">=</span> match <span class="op">+</span> [res.unwrap()[<span class="dv">0</span>]]
                rest <span class="op">=</span> res.unwrap()[<span class="dv">1</span>]
                res <span class="op">=</span> <span class="va">self</span>(rest)
            
            <span class="cf">return</span> Result.ok((match, rest))
            
        <span class="cf">return</span> Parser(repeat_func)
        
    <span class="kw">def</span> many1(<span class="va">self</span>, function<span class="op">=</span><span class="kw">lambda</span> x,y: x <span class="op">+</span> y):
        <span class="cf">return</span> <span class="va">self</span>.combine(<span class="va">self</span>.many(function), function)
    
    <span class="kw">def</span> many1_list(<span class="va">self</span>):
        <span class="cf">return</span> <span class="va">self</span>.combine(<span class="va">self</span>.many_list(function), function)
    
    <span class="kw">def</span> optional(<span class="va">self</span>):
        <span class="cf">return</span> <span class="va">self</span> <span class="op">|</span> Parser.empty()
    
    <span class="kw">def</span> first(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: x)
    
    <span class="kw">def</span> last(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: y)
    
    <span class="kw">def</span> <span class="bu">tuple</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.combine(other, <span class="kw">lambda</span> x,y: (x,y))

    <span class="kw">def</span> <span class="fu">__rshift__</span>(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.bind(function)
    
    <span class="kw">def</span> <span class="fu">__gt__</span>(<span class="va">self</span>, function):
        <span class="cf">return</span> <span class="va">self</span>.fmap(function)
    
    <span class="kw">def</span> <span class="fu">__ge__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.last(other)
    
    <span class="kw">def</span> <span class="fu">__le__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.first(other)
        
    <span class="kw">def</span> <span class="fu">__add__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.concat(other)
        
    <span class="kw">def</span> <span class="fu">__or__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.choice(other)

    <span class="kw">def</span> <span class="fu">__and__</span>(<span class="va">self</span>, other):
        <span class="cf">return</span> <span class="va">self</span>.<span class="bu">tuple</span>(other)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> char(cls, val):

        <span class="kw">def</span> match_char(text):
            <span class="cf">try</span>:
                current <span class="op">=</span> text[<span class="dv">0</span>]
            <span class="cf">except</span> <span class="pp">IndexError</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but &#39;</span> <span class="op">+</span>
                    <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(val)))
            
            <span class="cf">if</span> current <span class="op">==</span> val:
                <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to match character {} at {}&#39;</span>
                    .<span class="bu">format</span>(<span class="bu">repr</span>(val), <span class="bu">repr</span>(text)))

        <span class="cf">return</span> Parser(match_char)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> empty(cls):

        <span class="kw">def</span> match_empty(text):
            <span class="cf">return</span> Result.ok((<span class="st">&#39;&#39;</span>, text))

        <span class="cf">return</span> Parser(match_empty)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> oneof(cls, charls):

        <span class="kw">def</span> match_charls(text):
            <span class="cf">try</span>:
                current <span class="op">=</span> text[<span class="dv">0</span>]
            <span class="cf">except</span> <span class="pp">IndexError</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but one of &#39;</span> <span class="op">+</span>
                <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">list</span>(charls)))

            <span class="cf">if</span> current <span class="op">in</span> charls:
                <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;Failed to match one of {} at {}&#39;</span>
                    .<span class="bu">format</span>(<span class="bu">list</span>(charls), <span class="bu">repr</span>(text)))

        <span class="cf">return</span> Parser(match_charls)

    <span class="at">@classmethod</span>
    <span class="kw">def</span> noneof(cls, charls):

        <span class="kw">def</span> none_charls(text):
            <span class="cf">try</span>:
                current <span class="op">=</span> text[<span class="dv">0</span>]
            <span class="cf">except</span> <span class="pp">IndexError</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;End of String encountered, but none of &#39;</span> <span class="op">+</span>
                <span class="co">&#39;{} is still expected&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(text)))

            <span class="cf">if</span> current <span class="op">not</span> <span class="op">in</span> charls:
                <span class="cf">return</span> Result.ok((text[<span class="dv">0</span>], text[<span class="dv">1</span>:]))
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;Found one of {} at {} &#39;</span>
                    <span class="op">+</span><span class="st">&#39;when there should be none of&#39;</span>.<span class="bu">format</span>(<span class="bu">list</span>(charls), <span class="bu">repr</span>(text)))

        <span class="cf">return</span> Parser(none_charls)

    <span class="kw">def</span> parse_prefix(<span class="va">self</span>, string):
        <span class="cf">return</span> <span class="va">self</span>(string)

    <span class="kw">def</span> parse_total(<span class="va">self</span>, string):
        
        <span class="kw">def</span> check_full(tup):
            <span class="cf">if</span> tup[<span class="dv">1</span>] <span class="op">==</span> <span class="st">&#39;&#39;</span>:
                <span class="cf">return</span> Result.ok(tup[<span class="dv">0</span>])
            <span class="cf">else</span>:
                <span class="cf">return</span> Result.error(<span class="st">&#39;The match did not consist of the entire &#39;</span> <span class="op">+</span>
                    <span class="co">&#39;string: {} was left over&#39;</span>.<span class="bu">format</span>(<span class="bu">repr</span>(tup[<span class="dv">1</span>])))
            
        <span class="cf">return</span> <span class="va">self</span>(string) <span class="op">&gt;&gt;</span> check_full</code></pre></div>
